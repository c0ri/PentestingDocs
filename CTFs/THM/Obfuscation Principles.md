Task 1 - Introduction
---------------------------------

Obfuscation is an essential component of detection evasion methodology and preventing analysis of malicious software. Obfuscation originated to protect software and intellectual property from being stolen or reproduced. While it is still widely used for its original purpose, adversaries have adapted its use for malicious intent.

In this room, we will observe obfuscation from multiple perspectives and break down obfuscation methods.

### Learning Objectives

1.  Learn how to evade modern detection engineering using tool-agnostic obfuscation
2.  Understand the principles of obfuscation and its origins from intellectual property protection
3.  Implement obfuscation methods to hide malicious functions

Before beginning this room, familiarize yourself with basic programming logic and syntax. Knowledge of C and PowerShell is recommended but not required.

We have provided several machines with the required files and web servers to complete this room. Using the credentials below, you can access the machine and web server in-browser or through RDP.

Machine IP: `MACHINE_IP`             Username: `Student`             Password: `TryHackMe!`  

This is going to be a lot of information. Please put on your evil helmets and locate your nearest fire extinguisher.

__Questions__

Read the above and continue to the next task.
Answer: _None Needed_

Task 2 - Origins of Obfuscation
--------------------------------------------------

Obfuscation is widely used in many software-related fields to protect **IP** (**I**ntellectual **P**roperty) and other proprietary information an application may contain.

For example, the popular game: Minecraft uses the obfuscator [ProGuard](https://github.com/Guardsquare/proguard) to obfuscate and minimize its Java classes. Minecraft also releases **obfuscation maps** with limited information as a translator between the old un-obfuscated classes and the new obfuscated classes to support the modding community.

This is only one example of the wide range of ways obfuscation is publicly used. To document and organize the variety of obfuscation methods, we can reference the [Layered obfuscation: a taxonomy of software obfuscation techniques for layered security paper](https://cybersecurity.springeropen.com/track/pdf/10.1186/s42400-020-00049-3.pdf). This research paper organizes obfuscation methods by **layers**, similar to the OSI model but for application data flow. Below is the figure used as the complete overview of each taxonomy layer.

![[obfuscationprinciples-1.png]]

Each sub-layer is then broken down into specific methods that can achieve the overall objective of the sub-layer.

In this room, we will primarily focus on the **code-element layer** of the taxonomy, as seen in the figure below.

![[obfuscationprinciples-2.png]]

To use the taxonomy, we can determine an objective and then pick a method that fits our requirements. For example, suppose we want to obfuscate the layout of our code but cannot modify the existing code. In that case, we can inject junk code, summarized by the taxonomy:

`Code Element Layer` > `Obfuscating Layout` > `Junk Codes`.

But how could this be used maliciously? Adversaries and malware developers can leverage obfuscation to break signatures or prevent program analysis. In the upcoming tasks, we will discuss both perspectives of malware obfuscation, including the purpose and underlying techniques of each.

__Questions__

How many core layers make up the Layered Obfuscation Taxonomy?
Answer: _4_

What sub-layer of the Layered Obfuscation Taxonomy encompasses meaningless identifiers?
Answer: _Obfuscating Layout_

Task 3 - Obfuscation's Function for Static Evation
-----------------------------------------------------------------------------

Two of the more considerable security boundaries in the way of an adversary are **anti-virus engines** and **EDR** (**E**ndpoint **D**etection & **R**esponse) solutions. As covered in the [Introduction to Anti-virus room](https://tryhackme.com/room/introtoav), both platforms will leverage an extensive database of known signatures referred to as **static** signatures as well as **heuristic** signatures that consider application behavior.

To evade signatures, adversaries can leverage an extensive range of logic and syntax rules to implement obfuscation. This is commonly achieved by abusing data obfuscation practices that hide important identifiable information in legitimate applications.

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer. Below is a table of methods covered by the taxonomy in the **obfuscating data** sub-layer**.**

![[obfuscationprinciples-3.png]]

| Obfuscation Method     | Purpose                                                           |
| ---------------------- | ----------------------------------------------------------------- |
| Array Transformation   | Transforms an array by splitting, merging, folding and flattening |
| Data Encoding          | Encodes data with mathematical functions or ciphers               |
| Data Procedurization   | Substitutes static data with proceedure calls                     |
| Data Splitting/Merging | Distributes information of one varible into several new variables                                                                  |

In the upcoming tasks, we will primarily focus on **data splitting/merging**; because static signatures are weaker, we generally only need to focus on that one aspect in initial obfuscation.

Check out the Encoding/Packing/Binder/Crypters room for more information about **data encoding,** and the [Signature Evasion room](https://tryhackme.com/room/signatureevasion) for more information about **data procedurization** and **transformation**.

__Questions__

What obfuscation method will break or split an object?
Answer: _Data Splitting_

What obfuscation method is used to rewrite static data with a procedure call?
Answer: _Data Procedurization_

Task 4 - Object Concatenation
-------------------------------------------------

**Concatenation** is a common programming concept that combines two separate objects into one object, such as a string.

A pre-defined operator defines where the concatenation will occur to combine two independent objects. Below is a generic example of string concatenation in Python.

```python
>>> A = "Hello "
>>> B = "THM"
>>> C = A + B
>>> print(C)
Hello THM
>>>
```

Depending on the language used in a program, there may be different or multiple pre-defined operators than can be used for concatenation. Below is a small table of common languages and their corresponding pre-defined operators.

| Language   | Concatenation Operator               |
| ---------- | ------------------------------------ |
| Python     | "+"                                  |
| PowerShell | "+",","$", or no operator at all     |
| C#         | "+"", "String.Join", "String.Concat" |
| C          | "strcat"                             |
| C++        | "+", "append"                                     |

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under the **code-element** layer’s **data splitting/merging** sub-layer.

---

What does this mean for attackers? Concatenation can open the doors to several vectors to modify signatures or manipulate other aspects of an application. The most common example of concatenation being used in malware is breaking targeted **static signatures**, as covered in the [Signature Evasion room](https://tryhackme.com/room/signatureevasion). Attackers can also use it preemptively to break up all objects of a program and attempt to remove all signatures at once without hunting them down, commonly seen in obfuscators as covered in task 9.

Below we will observe a static **Yara** rule and attempt to use concatenation to evade the static signature.

```powershell
rule ExampleRule
{
    strings:
        $text_string = "AmsiScanBuffer"
        $hex_string = { B8 57 00 07 80 C3 }

    condition:
        $my_text_string or $my_hex_string
}
```

When a compiled binary is scanned with Yara, it will create a positive alert/detection if the defined string is present. Using concatenation, the string can be functionally the same but will appear as two independent strings when scanned, resulting in no alerts.

```powershell
IntPtr ASBPtr = GetProcAddress(TargetDLL, "AmsiScanBuffer"); 
```

If the second code block were to be scanned with the Yara rule, there would be no alerts!

---

Extending from concatenation, attackers can also use **non-interpreted characters** to disrupt or confuse a static signature. These can be used independently or with concatenation, depending on the strength/implementation of the signature. Below is a table of some common non-interpreted characters that we can leverage.

| Character   | Purpose                                                               | Example                 |
| ----------- | --------------------------------------------------------------------- | ----------------------- |
| Breaks      | Break a single string into multiple sub strings and combine them      | ('co'+'ffe'+'e')        |
| Reorders    | Reorder a string's components                                         | ('{1}{0}'-f'ffee','co') |
| Whitespace  | Include ticks that are not interpreted                                | d`own`LoAd`Strin`ng      |
| Random Case | Tokens are generally not case sensitive and can be any arbitrary case | dOwnLoAdsTRing                        |

Using the knowledge you have accrued throughout this task, obfuscate the following PowerShell snippet until it evades Defender’s detections.

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

To get you started, we recommend breaking up each section of the code and observe how it interacts or is detected. You can then break the signature present in the independent section and add another section to it until you have a clean snippet.

Once you think your snippet is sufficiently obfuscated, submit it to the webserver at `http://MACHINE_IP` ; if successful a flag will appear in a pop-up.

If you are still stuck we have provided a walkthrough of the solution below.

__Questions__

What flag is found after uploading a properly obfuscated snippet?

Just running the original query we get an error saying it is malicious. If we break it appart and just use the first part and separate the AnsiUtils, we can pass the filter.
![[obfuscationprinciples-4.png]]

We can do the same thing to the next part after tacking it onto the end of the cleared one we just did:
![[obfuscationprinciples-5.png]]

Let's just add the last part now:
![[obfuscationprinciples-6.png]]

Ok.. we get an error.  It seems that using these cmdlets together is tripping the filter. So let's try to use a variable to replace the SetValue cmdlet:
![[obfuscationprinciples-7.png]]

Bingo! Now we save this to a file 'test.ps1' on the desktop and submit it to `http://10.10.28.48`
![[obfuscationprinciples-8.png]]

Answer: _THM{koNC473n473_4LI_7H3_7H1n95}_

Task 5 - Obfuscation's Function for Analysis Deception
-------------------------------------------------------------------------------------

After obfuscating basic functions of malicious code, it may be able to pass software detections but is still susceptible to human analysis. While not a security boundary without further policies, analysts and reverse engineers can gain deep insight into the functionality of our malicious application and halt operations.

Adversaries can leverage advanced logic and mathematics to create more complex and harder-to-understand code to combat analysis and reverse engineering.

For more information about reverse engineering, check out the [Malware Analysis module](https://tryhackme.com/module/malware-analysis).

The aforementioned white paper: [Layered Obfuscation Taxonomy](https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3), summarizes these practices well under other sub-layers of the **code-element layer**. Below is a table of methods covered by the taxonomy in the **obfuscating layout** and **obfuscating controls sub-layers**.

![[obfuscationprinciples-9.png]]

| Obfuscation Method          | Purpose                                                                               |
| --------------------------- | ------------------------------------------------------------------------------------- |
| Junk Code                   | Add junk instructions that are non-functional, also known as code stubs               |
| Separation of Related Code  | Separate related codes or instructions to increase difficulty in reading the program  |
| Stripping Redundant Symbols | Strips symbolic information such as debug information or other symbol tables          |
| Meaningless Identifiers     | Transform a meaningful identifier to something meaningless                            |
| Implicit Controls           | Converts explicit controls instructions to implicit instructions                      |
| Dispatcher-based Controls   | Determines the next block to be executed during runtime                               |
| Probalistic Control Flows   | Introduces replications of control flows with the same semantics but different syntax |
| Bogus Control Flows         | Control flows deliberately added to a program but will never be executed                                                                                      |

In the upcoming tasks, we will demonstrate several of the above methods in an agnostic format.

Check out the [Sandbox Evasion room](https://tryhackme.com/room/sandboxevasion) for more information about anti-analysis and anti-reversing

__Questions__

What are junk instructions referred to as in junk code?
Answer: _code stubs_

What obfuscation layer aims to confuse an analyst by manipulating the code flow and abstract syntax trees?
Answer: _Obfuscating Controls_

Task 6 - Code Flow and Logic
-------------------------------------------------

**Control flow** is a critical component of a program’s execution that will define how a program will logically proceed. **Logic** is one of the most significant determining factors to an application’s control flow and encompasses various uses such as **if/else statements** or **for loops**. A program will traditionally execute from the top-down; when a logic statement is encountered, it will continue execution by following the statement.

Below is a table of some logic statements you may encounter when dealing with control flows or program logic.

| Logic Statement | Purpose                                                                                                                                                              |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| if/else         | Executes only if a condition is met, else it will execute a different code block                                                                                     |
| try/catch       | Will try to execute a code block and catch it if it fails to handle errors                                                                                           |
| switch case     | A switch will follow similar conditional logic to an if statement but checks several different possible conditions with cases before resolving to a break or default |
| for/while loop  | A for loop will execute for a set amount of a condition. A while loop will execute until a condition is no longer met                                                                                                                                                                     |

To make this concept concrete, we can observe an example function and its corresponding **CFG** (**C**ontrol **F**low **G**raph) to depict it’s possible control flow paths.

```python
x = 10 
if(x > 7):
	print("This executes")
else:
	print("This is ignored")
```

![[obfuscationprinciples-10.png]]

What does this mean for attackers? An analyst can attempt to understand a program’s function through its control flow; while problematic, logic and control flow is almost effortless to manipulate and make arbitrarily confusing. When dealing with control flow, an attacker aims to introduce enough obscure and arbitrary logic to confuse an analyst but not too much to raise further suspicion or potentially be detected by a platform as malicious.

In the upcoming task, we will discuss different control flow patterns an attacker can use to confuse an analyst.

Can logic change and impact the control flow of a program? (T/F)
Answer: _T_

