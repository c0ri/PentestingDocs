<span class="highlight" style="color: #ad74fc; background-color:  #28015e">Learn how to interact with the win32 API and understand its wide range of use cases</span>
#winapi

Task 1 - Introduction
----------------------------------

The Windows API provides native functionality to interact with key components of the Windows operating system. The API is widely used by many, including red teamers, threat actors, blue teamers, software developers, and solution providers.

The API can integrate seamlessly with the Windows system, offering its range of use cases. You may see the Win32 API being used for offensive tool and malware development, **EDR** (**E**ndpoint **D**etection & **R**esponse) engineering, and general software applications. For more information about all of the use cases for the API, check out the [Windows API Index](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list).

### Learning Objectives

1.  Understand what the Windows API is, its use cases, and how it interacts with the OS subsystems
2.  Learn how to implement the Windows API in different languages
3.  Understand how the Windows API can be used from a malicious perspective and break down several practical case studies

Before beginning this room, we recommend general familiarity with operating system architecture. Basic programming knowledge is also recommended but not required.

This room aims to teach the Windows API at a fundamental level. We will briefly cover implementations of the Win32 API, but we will focus on why and where API calls are used.

Please buckle your seat belts and locate your nearest exit.

__Questions__

Read the above and continue to the next task.
Answer: _None Needed_

Task 2 - Subsystem and Hardware Interaction
---------------------------------------------------------------------------

Programs often need to access or modify Windows subsystems or hardware but are restricted to maintain machine stability. To solve this problem, Microsoft released the Win32 API, a library to interface between user-mode applications and the kernel.

Windows distinguishes hardware access by two distinct modes: **user** and **kernel mode**. These modes determine the hardware, kernel, and memory access an application or driver is permitted. API or system calls interface between each mode, sending information to the system to be processed in kernel mode.

| User mode                          | Kernel mode            |
| ---------------------------------- | ---------------------- |
| No direct hardware access          | Direct hardware access |
| Access to "owned" memory locations | Access to entire physical memory                       |

For more information about memory management, check out [Windows Internals](https://tryhackme.com/room/windowsinternals).

Below is a visual representation of how a user application can use API calls to modify kernel components.

![[windowsapi-1.png]]

When looking at how languages interact with the Win32 API, this process can become further warped; the application will go through the language runtime before going through the API.

For more information about the runtime, check out [Runtime Detection Evasion](https://tryhackme.com/room/runtimedetectionevasion).

__Questions__

Does a process in the user mode have direct hardware access? (Y/N)
Answer: _N_

Does launching an application as an administrator open the process in kernel mode? (Y/N)
Answer: _N_

Task 3 - Components of the Windows API
-----------------------------------------------------------------

The Win32 API, more commonly known as the Windows API, has several dependent components that are used to define the structure and organization of the API.

Let’s break the Win32 API up via a top-down approach. We’ll assume the API is the top layer and the parameters that make up a specific call are the bottom layer. In the table below, we will describe the top-down structure at a high level and dive into more detail later.

| Layer                   | Explanation                                                                                                                                                                 |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| API                     | A top-local term/theory use to desctribe and call found in win32 API structure                                                                                              |
| Header files or imports | Defines libs to be imported at run-time, defined by heasder files or lib imports. Uses pointers to obtain the function address                                              |
| Core DLLs               | A group of four DLLs that define call structures. (KERNEL32, USER32, and ADVAPI32). These DLLs define kernel and user services that are not contained in a single subsystem |
| Supplemental DLLs       | Other DLLs defined as part of the Windows API. Controls separate subsystems of the Windows OS. ~36 other defined DLLs. (NTDLL, COM, FVEAPI, etc.)                           |
| Call Structures         | Defines the API call itself and parameters of the call                                                                                                                      |
| API Calls               | The API call used within a program, with fucntion addresses obtained from pointers                                                                                          |
| In/Out Parameters       | The parameter values that are defined by the call structures                                                                                                                                                                            |

Let’s expand these definitions; in the next task, we will discuss importing libraries, the core header file, and the call structure. In task 4, we will dive deeper into the calls, understanding where and how to digest call parameters and variants.

__Questions__

What header file imports and defines the User32 DLL and structure?
**Note:** This questions requires external research https://en.wikipedia.org/wiki/Windows.h
Answer: _winuser.h_

What parent header file contains all other required child and core header files?
**Note:** This questions requires external research https://en.wikipedia.org/wiki/Windows.h
Answer: _windows.h_

Task 4 - OS Libraries
--------------------------------------

Each API call of the Win32 library resides in memory and requires a pointer to a memory address. The process of obtaining pointers to these functions is obscured because of **ASLR** (**A**ddress **S**pace **L**ayout **R**andomization) implementations; each language or package has a unique procedure to overcome ASLR. Throughout this room, we will discuss the two most popular implementations: **[P/Invoke](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)** and the **[Windows header file](https://docs.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers)**.

In this task, we will take a deep dive into the theory of how both of these implementations work, and in future tasks, we will put them to practical use.

### Windows Header File

Microsoft has released the Windows header file, also known as the Windows loader, as a direct solution to the problems associated with ASLR’s implementation. Keeping the concept at a high level, at runtime, the loader will determine what calls are being made and create a thunk table to obtain function addresses or pointers.

Luckily, we do not have to dive deeper than that to continue working with API calls if we do not desire to do so.

Once the `windows.h` file is included at the top of an unmanaged program; any Win32 function can be called.

We will cover this concept at a more practical level in task 6.

### P/Invoke

Microsoft describes P/Invoke or platform invoke as “a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.”

P/invoke provides tools to handle the entire process of invoking an unmanaged function from managed code or, in other words, calling the Win32 API. P/invoke will kick off by importing the desired DLL that contains the unmanaged function or Win32 API call. Below is an example of importing a DLL with options.

```csharp
using System;
using System.Runtime.InteropServices;

public class Program
{
[DllImport("user32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
...
} 
```

In the above code, we are importing the DLL `user32` using the attribute: `DLLImport`.

Note: a semicolon is not included because the p/invoke function is not yet complete. In the second step, we must define a managed method as an external one. The `extern` keyword will inform the runtime of the specific DLL that was previously imported. Below is an example of creating the external method.

```csharp
using System;
using System.Runtime.InteropServices;

public class Program
{
...
private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);
} 
```

Now we can invoke the function as a managed method, but we are calling the unmanaged function!

We will cover this concept at a more practical level in task 7.

__Questions__

What overarching namespace provides P/Invoke to .NET?
**NOTE:** This is very broad, but Most of the P/Invoke API is contained in two namespaces: **System** and **Runtime**.
Answer: _System_

What memory protection solution obscures the process of importing API calls?
Answer: _ASLR_

Task 5 - API Call Structure
-------------------------------------------

API calls are the second main component of the Win32 library. These calls offer extensibility and flexibility that can be used to meet a plethora of use cases. Most Win32 API calls are well documented under the [Windows API documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list) and [pinvoke.net](http://pinvoke.net/).

In this task, we will take an introductory look at naming schemes and in/out parameters of API calls.

API call functionality can be extended by modifying the naming scheme and appending a representational character. Below is a table of the characters Microsoft supports for its naming scheme.

| Character | Explanation                                          |
| --------- | ---------------------------------------------------- |
| A         | Represents an 8-bit character set with ASNI encoding |
| W         | Represents a Unicode encoding                        |
| Ex        | Provides extended functionality in/out parameters to the API call                                                     |

For more information about this concept, check out the [Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings).

---

Each API call also has a pre-defined structure to define its in/out parameters. You can find most of these structures on the corresponding API call document page of the [Windows documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list), along with explanations of each I/O parameter.

Let’s take a look at the `WriteProcessMemory` API call as an example. Below is the I/O structure for the call obtained [here](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory).

```cpp
BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,
  [in]  LPCVOID lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);
```

For each I/O parameter, Microsoft also explains its use, expected input or output, and accepted values.

Even with an explanation determining these values can sometimes be challenging for particular calls. We suggest always researching and finding examples of API call usage before using a call in your code.

__Questions__

Which character appended to an API call represents an ANSI encoding?
Answer: _A_

Which character appended to an API call represents extended functionality?
Answer: _Ex_

What is the memory allocation type of 0x00080000 in the VirtualAlloc API call?
This is part of the aforementioned  [Windows documentation](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list). Specifically the VirtualAlloc function or memoryapi.h headers. In declaring the memory allocation you must specifiy the type, of which 0x00080000 is one possible type called MEM_RESET. Please see all of the detailed info on this here [NF MemoryAPI Virtual Alloc](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc).

