Task 1 - Introduction
-----------------------------------

In this room we will assume we have successfully gained a foothold of some sort on the machine and we will begin enumeration.  We have already escalated  and may already have Administrator or root priviledges on the target system. 

For Privilege escalation, we have covered that in other rooms but check out the scripts, [WinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS) and [LinPEAS](https://grimbins.github.io/grimbins/linpeas/) for MS Windows and Linux privilege escalation respectively.

Our focus here however, is to collect as much information as possible so that we can gain further access on the network and get access to other systems.  We focus on common tools available on most systems. Being part of the system they are least likely to be removed or draw attention, and also cause the least "noise".

Typically if we have a shell on the target it's possible to shift to another type of shell.  For example if we have a windows command prompt `cmd.exe` then we can just type `powershell.exe` to get a Windows powershell prompt.

```shell
$ Microsoft Windows [Version 10.0.17763.2928]
(c) 2018 Microsoft Corporation. All rights reserved.

strategos@RED-WIN-ENUM C:\Users\strategos>powershell.exe
Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

PS C:\Users\strategos>
```

This room is organized as follows:

-   Purpose of enumeration
-   Linux enumeration with commonly-installed tools: System, users, networking, and running services
-   MS Windows enumeration with built-in tools: System, users, networking, and running services
-   Examples of additional tools: Seatbelt

__Questions__
What command would you use to start the PowerShell interactive command line?
Answer: _powershell.exe_


Task 2 - Purpose
-----------------------------

When you first get a shell, you may have basic knowledge of the system such as the service you attacked, what OS is running etc. but the box will seem like a dark room because you don't yet have any knowledge of what's around you. It's important to enumerate to find out more details.

The purpose of post-exploitation enumeration is to get more details on the system and the network.  The aim is to get information needed to pivot to other systems if needed or to loot the current system. Some of the information we are interested in gathering include:

-   Users and groups
-   Hostnames
-   Routing tables
-   Network shares
-   Network services
-   Applications and banners
-   Firewall configurations
-   Service settings and audit configurations
-   SNMP and DNS details
-   Hunting for credentials (saved on web browsers or client applications)

There is really no way to tell what we might stumble upon. There could be SSH keys that grant us access to other systems.

We might stumble upon sensative data in the user's documents. 

There might be a password file or keepass database we can crack. 

__Questions__

In SSH key-based authentication, which key does the client need?
Answer: _private key_


Task 3 - Linux Enumeration
------------------------------------------

In this task we will cover some basic Linux enumeration techniques. Here are some of the areas we will cover:

-   System
-   Users
-   Networking
-   Running Services

### System

We can get system information from finding out which release we have.

`ls /etc/*-release`

`cat /etc/os-release`

It can be different between some flavors of linux. For example Ubuntu and Fedora have different locations.

For RedHat/Fedora/CentOS flavors:

`cat /etc/redhat-release`

If we want to find out the hostname of the target:

`hostname`

There is a lot of other useful files we can example for further information:

```bash
/etc/passwd
/etc/group
/etc/shadow
```

We can check mail directories:

`ls -lh /var/mail/`

Find installed apps under 

```bash
/usr/bin
/usr/local/bin
/usr/sbin
```

Or find packages installed on a RPM-based distro like Redhat by using the RPM command to query:

`rpm -qa`

On Debian distros like Ubuntu/Kali we can use:

`dpkg -l`

### Users

We can look in the /etc/passwd to find users.

`cat /etc/passwd`

We can see who is logged in with `who` or `w`. The latter also lists what they are currently doing.

We can see who the system thinks we are:

`whoami`

We can use the `id` command to find our effective user and group IDS.

We can use `groups user` to show what groups a member belongs to.

We can issue the `last` command to show all the users who have logged in.

We can use `sudo -l` to show what SUDO commands our effective user can run with root permissions.

### Networking

We can show our current IP with:
`ip address show` or `ip a s` (for short) or just `ip a`

Some systems use the older method `ipconfig -a` where -a is for all interfaces. We can also just specify one interface such as `ifconfig eth0`

We can find configured DNS servers is `/etc/resolve.conf`

`netstat` is a very useful tool. It  will show us about network connections, routing tables and interface stats. Here is a helpful table:

| Option | Description                                                       |
| ------ | ----------------------------------------------------------------- |
| -a     | Show both listening and non-listening sockets                     |
| -l     | Show only listening sockets                                       |
| -n     | Show numeric and skip host resolution                             |
| -t     | TCP                                                               |
| -u     | UDP                                                               |
| -x     | UNIX                                                              |
| -p     | Show the PID and name of the program to which the socket belongs. |
|        |                                                                   |


You can mix these flags how you want to show the information you require. The flags can help filter the potentially longggg list of information this command will spit out.

For example:
`sudo netstat -plt` - Shows programs listening on TCP sockets
`sudo netstat -atupn` - Shows all TCP and UDP established connections in numeric form without resolution. It should be noted that the -n flag is also much faster because it skips DNS requests which can hang and lag.

LSOF is another helpful command. It stands for List of Open Files. If we want to display only internet and network connections we can use `lsof -i`.  To list everything you would need to run that command as root with sudo `sudo lsof -i`.

LSOF outputs can be very long.  we can limit the output like this:
`sudo lsof -i :25` which show processes listening on port 25.

We can search for listening processes:
`sudo lsof |grep LISTEN`

For established connections:
`sudo lsof |grep ESTABLISHED`

### Running Services

We can get an idea of what processes are running using the `ps` command. There are some helpful flags for this command as well:

| Option | Description         |
| ------ | ------------------- |
| -e     | all processes       |
| -f     | full-format listing |
| -j     | jobs format         |
| -l     | long format         |
| -u     | user-oriented format                    |


or more “visual” output, you can issue `ps axjf` to print a process tree. The `f` stands for “forest”, and it creates an ASCII art process hierarchy as shown in the terminal output below.

```bash
$ ps axf
   PID TTY      STAT   TIME COMMAND
     2 ?        S      0:00 [kthreadd]
     4 ?        S<     0:00  \_ [kworker/0:0H]
     5 ?        S      0:01  \_ [kworker/u256:0]
[...]
   978 ?        Ss     0:00 /usr/sbin/sshd -D
  5665 ?        Ss     0:00  \_ sshd: peter [priv]
  5693 ?        S      0:00  |   \_ sshd: peter@pts/1
  5694 pts/1    Ss     0:00  |       \_ -bash
  5713 pts/1    S+     0:00  |           \_ vi notes.txt
  5723 ?        Ss     0:00  \_ sshd: jane [priv]
  5727 ?        S      0:00      \_ sshd: jane@pts/0
  5728 pts/0    Ss     0:00          \_ -bash
  7080 pts/0    R+     0:00              \_ ps axf
   979 ?        Ssl    0:12 /usr/bin/python2 -Es /usr/sbin/tuned -l -P
   981 ?        Ssl    0:07 /usr/sbin/rsyslogd -n
  1141 ?        Ss     0:00 /usr/libexec/postfix/master -w
  1147 ?        S      0:00  \_ qmgr -l -t unix -u
  6991 ?        S      0:00  \_ pickup -l -t unix -u
  1371 ?        Ss     0:00 login -- root
  1376 tty1     Ss     0:00  \_ -bash
  1411 tty1     S+     0:00      \_ man man
  1420 tty1     S+     0:00          \_ less -s
[...]
```

To summarize, remember to use `ps -ef` or `ps aux` to get a list of all the running processes. Consider piping the output via `grep` to display output lines with certain words. The terminal output below shows the lines with `peter` in them.

```bash
$ ps -ef | grep peter
root       5665    978  0 07:11 ?        00:00:00 sshd: peter [priv]
peter      5693   5665  0 07:13 ?        00:00:00 sshd: peter@pts/1
peter      5694   5693  0 07:13 pts/1    00:00:00 -bash
peter      5713   5694  0 07:13 pts/1    00:00:00 vi notes.txt
```

__Questions__

What is the Linux distribution used in the VM?
Answer:

What is its version number?
Answer: _Ubuntu_

What is its version number?
Answer: _20.04.4_

What is the name of the user who last logged in to the system?
Answer: _randa_

What is the highest listening TCP port number?
Answer: _6667_

What is the program name of the service listening on it?
Answer: _inspircd_

There is a script running in the background. Its name starts with `THM`. What is the name of the script?
Answer: _THM-24765.sh_

Task 4 - Windows Enumeration
--------------------------------------------------

In this task we will assume we have access to `cmd` on a Windows host. Maybe we already have shell access via a reverse shell or something. 

Here we will focus on enumerating the local Windows sytem (not AD)

### System

One command that can give us detailed information about the system, such as its build number and installed patches, would be `systeminfo`. In the example below, we can see which hotfixes have been installed.

```shell
C:\>systeminfo

Host Name:                 WIN-SERVER-CLI
OS Name:                   Microsoft Windows Server 2022 Standard
OS Version:                10.0.20348 N/A Build 20348
OS Manufacturer:           Microsoft Corporation
[...]
Hotfix(s):                 3 Hotfix(s) Installed.
                           [01]: KB5013630
                           [02]: KB5013944
                           [03]: KB5012673
Network Card(s):           1 NIC(s) Installed.
                           [01]: Intel(R) 82574L Gigabit Network Connection
[...]
```

You can check installed updates using `wmic qfe get Caption, Description`. This information will give you an idea of how quickly systems are being patched and updated.

```shell
C:\>wmic qfe get Caption, Description
Caption                                     Description      
http://support.microsoft.com/?kbid=5013630  Update
https://support.microsoft.com/help/5013944  Security Update
                                            Update
```

You can check the installed and started Windows services using `net start`. Expect to get a long list; the output below has been snipped.

```shell
C:\>net start
These Windows services are started:

   Base Filtering Engine
   Certificate Propagation
   Client License Service (ClipSVC)
   COM+ Event System
   Connected User Experiences and Telemetry
   CoreMessaging
   Cryptographic Services
   DCOM Server Process Launcher
   DHCP Client
   DNS Client
[...]
   Windows Time
   Windows Update
   WinHTTP Web Proxy Auto-Discovery Service
   Workstation

The command completed successfully.
```

If you are only interested in installed apps, you can issue `wmic product get name,version,vendor`. If you run this command on the attached virtual machine, you will get something similar to the following output.

```shell
C:\>wmic product get name,version,vendor
Name                                                            Vendor                                   Version
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29910     Microsoft Corporation                    14.28.29910
[...]
Microsoft Visual C++ 2019 X64 Additional Runtime - 14.28.29910  Microsoft Corporation                    14.28.29910
```

### Users

To know who you are, you can run `whoami`; moreover, to know what you are capable of, i.e., your privileges, you can use `whoami /priv`. An example is shown in the terminal output below.

```shell
C:\>whoami
win-server-cli\strategos

> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                            Description                                                        State
========================================= ================================================================== =======
SeIncreaseQuotaPrivilege                  Adjust memory quotas for a process                                 Enabled
SeSecurityPrivilege                       Manage auditing and security log                                   Enabled
SeTakeOwnershipPrivilege                  Take ownership of files or other objects                           Enabled
[...]
```

Moreover, you can use `whoami /groups` to know which groups you belong to. The terminal output below shows that this user belongs to the `NT AUTHORITY\Local account and member of Administrators group` among other groups.

```shell
C:\>whoami /groups

GROUP INFORMATION
-----------------

Group Name                                                    Type             SID          Attributes
============================================================= ================ ============ ===============================================================
Everyone                                                      Well-known group S-1-1-0      Mandatory group, Enabled by default, Enabled group
NT AUTHORITY\Local account and member of Administrators group Well-known group S-1-5-114    Mandatory group, Enabled by default, Enabled group
BUILTIN\Administrators                                        Alias            S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner
[...]
```

You can view users by running `net user`.

```shell
C:\>net user

User accounts for \\WIN-SERVER-CLI

-------------------------------------------------------------------------------
Administrator            DefaultAccount           Guest
michael                  peter                    strategos
WDAGUtilityAccount
The command completed successfully.
```

You can discover the available groups using `net group` if the system is a Windows Domain Controller or `net localgroup` otherwise, as shown in the terminal below.

```shell
C:\>net localgroup

Aliases for \\WIN-SERVER-CLI

-------------------------------------------------------------------------------
*Access Control Assistance Operators
*Administrators
*Backup Operators
*Certificate Service DCOM Access
*Cryptographic Operators
*Device Owners
[...]
```

You can list the users that belong to the local administrators’ group using the command `net localgroup administrators`.

```shell
C:\>net localgroup administrators Alias name administrators Comment Administrators have complete and unrestricted access to the computer/domain Members ------------------------------------------------------------------------------- Administrator michael peter strategos The command completed successfully.
```

Use `net accounts` to see the local settings on a machine; moreover, you can use `net accounts /domain` if the machine belongs to a domain. This command helps learn about password policy, such as minimum password length, maximum password age, and lockout duration.

### Networking

You can use the `ipconfig` command to learn about your system network configuration. If you want to know all network-related settings, you can use `ipconfig /all`. The terminal output below shows the output when using `ipconfig`. For instance, we could have used `ipconfig /all` if we wanted to learn the DNS servers.

```shell
C:\>ipconfig

Windows IP Configuration


Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : localdomain
   Link-local IPv6 Address . . . . . : fe80::3dc5:78ef:1274:a740%5
   IPv4 Address. . . . . . . . . . . : 10.20.30.130
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.20.30.2
```

On MS Windows, we can use `netstat` to get various information, such as which ports the system is listening on, which connections are active, and who is using them. In this example, we use the options `-a` to display all listening ports and active connections. The `-b` lets us find the binary involved in the connection, while `-n` is used to avoid resolving IP addresses and port numbers. Finally, `-o` display the process ID (PID).

In the partial output shown below, we can see that `netstat -abno` showed that the server is listening on TCP ports 22, 135, 445 and 3389. The processes`sshd.exe`, `RpcSs`, and `TermService` are on ports `22`, `135`, and `3389`, respectively. Moreover, we can see two established connections to the SSH server as indicated by the state `ESTABLISHED`.

```shell
C:\>netstat -abno

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:22             0.0.0.0:0              LISTENING       2016
 [sshd.exe]
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       924
  RpcSs
 [svchost.exe]
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4
 Can not obtain ownership information
  TCP    0.0.0.0:3389           0.0.0.0:0              LISTENING       416
  TermService
 [svchost.exe]
[...]
  TCP    10.20.30.130:22        10.20.30.1:39956       ESTABLISHED     2016
 [sshd.exe]
  TCP    10.20.30.130:22        10.20.30.1:39964       ESTABLISHED     2016
 [sshd.exe]
[...]
```

You might think that you can get an identical result by port scanning the target system; however, this is inaccurate for two reasons. A firewall might be blocking the scanning host from reaching specific network ports. Moreover, port scanning a system generates a considerable amount of traffic, unlike `netstat`, which makes zero noise.

Finally, it is worth mentioning that using `arp -a` helps you discover other systems on the same LAN that recently communicated with your system. ARP stands for Address Resolution Protocol; `arp -a` shows the current ARP entries, i.e., the physical addresses of the systems on the same LAN that communicated with your system. An example output is shown below. This indicates that these IP addresses have communicated somehow with our system; the communication can be an attempt to connect or even a simple ping. Note that `10.10.255.255` does not represent a system as it is the subnet broadcast address.

```shell
C:\>arp -a

Interface: 10.10.204.175 --- 0x4 
  Internet Address      Physical Address      Type
  10.10.0.1             02-c8-85-b5-5a-aa     dynamic
  10.10.16.117          02-f2-42-76-fc-ef     dynamic
  10.10.122.196         02-48-58-7b-92-e5     dynamic
  10.10.146.13          02-36-c1-4d-05-f9     dynamic
  10.10.161.4           02-a8-58-98-1a-d3     dynamic
  10.10.217.222         02-68-10-dd-be-8d     dynamic
  10.10.255.255         ff-ff-ff-ff-ff-ff     static
```

Start the attached MS Windows Server if you have not done so already, as you need it to answer the questions below. You can connect to the MS Windows VM via SSH from the AttackBox, for example, using `ssh user@MACHINE_IP` where the login credentials are:

-   Username: `user`
-   Password: `THM33$$88`

__Questions__

What is the full OS Name?
Answer: __

What is the OS Version?
Answer: __

How many hotfixes are installed on this MS Windows Server?
Answer: __

What is the lowest TCP port number listening on the system?
Answer: __

What is the name of the program listening on that port?
Answer: __


